<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Infinity TD</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600&display=swap"
        rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://pixijs.download/v8.6.6/pixi.min.js"></script>

    <script>
        const keys = Object.keys(window.React);
        const exports = keys.map(k => `export const ${k} = window.React['${k}'];`).join('\n');
        const blob = new Blob([`export default window.React;\n${exports}`], { type: 'application/javascript' });
        const reactUrl = URL.createObjectURL(blob);
        const importMap = { imports: { "react": reactUrl, "zustand/vanilla": "https://esm.sh/zustand@4.5.0/vanilla?external=react", "use-sync-external-store/shim/with-selector": "https://esm.sh/use-sync-external-store@1.2.0/shim/with-selector.js?external=react" } };
        const im = document.createElement('script');
        im.type = 'importmap';
        im.textContent = JSON.stringify(importMap);
        document.head.appendChild(im);
    </script>
    <script type="module">
        // @ts-check
        import { createStore } from 'zustand/vanilla';
        import { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector';

        const create = (createState) => {
            const api = createStore(createState);
            const useStore = (selector, equalityFn) => { return useSyncExternalStoreWithSelector(api.subscribe, api.getState, api.getState, selector, equalityFn); };
            Object.assign(useStore, api);
            return useStore;
        };
        window.createZustand = create;
        window.createVanillaStore = createStore;
    </script>
    <style>
        @keyframes fade-in {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes fade-in-up {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fade-in-right {
            from {
                opacity: 0;
                transform: translateX(20px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes scanline {
            0% {
                background-position: 0 0;
            }

            100% {
                background-position: 0 100%;
            }
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.7;
                transform: scale(1.05);
            }
        }

        @keyframes slow-glow {

            0%,
            100% {
                opacity: 0.6;
                transform: scale(1);
            }

            50% {
                opacity: 1;
                transform: scale(1.02);
            }
        }

        @keyframes slow-spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        .animate-fade-in {
            animation: fade-in 0.5s ease-out forwards;
        }

        .animate-fade-in-up {
            animation: fade-in-up 0.4s ease-out forwards;
        }

        .animate-fade-in-right {
            animation: fade-in-right 0.4s ease-out forwards;
        }

        .scanlines {
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 50%, rgba(0, 0, 0, 0.1) 50%, rgba(0, 0, 0, 0.1));
            background-size: 100% 4px;
            animation: scanline 0.2s linear infinite;
        }

        .retro-grid {
            background-image: linear-gradient(rgba(30, 41, 59, 0.3) 1px, transparent 1px), linear-gradient(90deg, rgba(30, 41, 59, 0.3) 1px, transparent 1px);
            background-size: 40px 40px;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background-color: #050505;
            color: #e0f2fe;
            overflow: hidden;
        }

        h1,
        h2,
        h3,
        .title-font {
            font-family: 'Orbitron', sans-serif;
        }

        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #0f172a;
        }

        ::-webkit-scrollbar-thumb {
            background: #38bdf8;
            border-radius: 3px;
        }
    </style>

</head>

<body>
    <div id="root"></div>
    <script type="text/babel" data-presets="react">
        const { useRef, useEffect, useState, useCallback } = React;

        // ==================== ENUMS & TYPES ====================
        const Icon = ({ name,
            size = 24,
            color = "currentColor",
            className,
            ...props }) => {
            const iconDef = window.lucide?.icons?.[name];
            if (!iconDef) return <span className={className}>{name}</span>;

            return (
                <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={color} strokeWidth={2} strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>
                    {iconDef.map(([childTag, childAttrs], i) => React.createElement(childTag, { ...childAttrs, key: i }))}
                </svg>
            );
        };
        const { Zap,
            Shield,
            Crosshair,
            Activity,
            Cpu,
            Lock,
            Flame,
            Snowflake,
            Coins,
            Database,
            ArrowUpCircle,
            Trash2,
            X,
            Pause,
            Target,
            Save,
            Upload,
            Bomb,
            Hexagon,
            GalleryVerticalEnd,
            Divide,
            Info,
            Biohazard,
            Play,
            FastForward,
            Grip,
            Music,
            DollarSign,
            CircleDollarSign,
            Circle,
            Star } = Object.fromEntries([
                'Zap',
                'Shield',
                'Crosshair',
                'Activity',
                'Cpu',
                'Lock',
                'Flame',
                'Snowflake',
                'Coins',
                'Database',
                'ArrowUpCircle',
                'Trash2',
                'X',
                'Pause',
                'Target',
                'Save',
                'Upload',
                'Bomb',
                'Hexagon',
                'GalleryVerticalEnd',
                'Divide',
                'Info',
                'Biohazard',
                'Play',
                'FastForward',
                'Grip',
                'Music',
                'DollarSign',
                'CircleDollarSign',
                'Circle',
                'Star'
            ].map(name => [name, (props) => <Icon name={name} {...props} />]));
        const GameStatus = {
            IDLE: 'IDLE',
            PLAYING: 'PLAYING',
            GAME_OVER: 'GAME_OVER'
        };

        const EnemyType = {
            BASIC: 'BASIC',
            FAST: 'FAST',
            TANK: 'TANK',
            SPLITTER: 'SPLITTER',
            SPLITTER_BIT: 'SPLITTER_BIT',
            MINIBOSS: 'MINIBOSS',
            BOSS: 'BOSS',
            SHOOTER: 'SHOOTER',   // Hard Mode: Ranged enemy that fires at core
            DODGER: 'DODGER'      // Hard Mode: Evades projectiles
        };

        const EnemyTrait = {
            ARMORED: 'ARMORED',
            RESIST_SLOW: 'RESIST_SLOW',
            RESIST_STUN: 'RESIST_STUN',
            REGEN: 'REGEN'
        };

        const TurretType = {
            BLASTER: 'BLASTER',
            SNIPER: 'SNIPER',
            AOE: 'AOE',
            RAPID: 'RAPID',
            CANNON: 'CANNON',
            FREEZE: 'FREEZE',
            SHOCK: 'SHOCK',
            MISSILE: 'MISSILE',
            PRISM: 'PRISM',
            FLAMETHROWER: 'FLAMETHROWER',
            RAILGUN: 'RAILGUN',
            ACID: 'ACID',
            GRAVITY_WELL: 'GRAVITY_WELL'
        };

        const UpgradeType = {
            GLOBAL_DAMAGE: 'GLOBAL_DAMAGE',
            GLOBAL_RANGE: 'GLOBAL_RANGE',
            GLOBAL_RATE: 'GLOBAL_RATE',
            MULTISHOT: 'MULTISHOT',
            CRIT_CHANCE: 'CRIT_CHANCE',
            CRIT_DAMAGE: 'CRIT_DAMAGE',
            MAX_HEALTH: 'MAX_HEALTH',
            DAMAGE_REDUCTION: 'DAMAGE_REDUCTION'
        };

        const MetaUpgradeType = {
            STARTING_CASH: 'STARTING_CASH',
            CORE_SHIELDING: 'CORE_SHIELDING',
            SCRAP_RECYCLING: 'SCRAP_RECYCLING',
            TURRET_MASTERY: 'TURRET_MASTERY',
            DISCOUNT_ENGINEERING: 'DISCOUNT_ENGINEERING'
        };

        // Mutations applied every 15 waves - kept minimal for performance
        const MutationType = {
            ENEMY_HP: 'ENEMY_HP',           // +30% enemy HP
            ENEMY_SPEED: 'ENEMY_SPEED',      // +20% enemy speed
            ENEMY_REGEN: 'ENEMY_REGEN',      // All enemies regenerate
            ARMORED_WAVE: 'ARMORED_WAVE'     // 50% enemies are armored
        };
        const MUTATION_DEFS = {
            [MutationType.ENEMY_HP]: {
                name: 'Thick Skin',
                mult: { enemyHp: 1.3 },
                isBuff: false
            },
            [MutationType.ENEMY_SPEED]: {
                name: 'Swift Horde',
                mult: { enemySpeed: 1.2 },
                isBuff: false
            },
            [MutationType.ENEMY_REGEN]: {
                name: 'Regeneration',
                trait: 'REGEN',
                isBuff: false
            },
            [MutationType.ARMORED_WAVE]: {
                name: 'Iron Swarm',
                armorChance: 0.5,
                isBuff: false
            }
        };

        // Evolution paths - turrets can evolve by spending money
        const EvolutionType = {
            BLASTER_PLASMA: 'BLASTER_PLASMA',     // High single-target
            BLASTER_SCATTER: 'BLASTER_SCATTER',   // Shotgun spread
            MISSILE_NAPALM: 'MISSILE_NAPALM',     // Fire trail
            MISSILE_SWARM: 'MISSILE_SWARM',       // Many small missiles
            FREEZE_PERMA: 'FREEZE_PERMA',         // Longer freeze
            FREEZE_BLIZZARD: 'FREEZE_BLIZZARD',   // Huge AoE
            SHOCK_OVERLOAD: 'SHOCK_OVERLOAD',     // Longer stun
            SHOCK_STORM: 'SHOCK_STORM'            // AoE to stunned
        };
        const EVOLUTION_PATHS = {
            BLASTER: [EvolutionType.BLASTER_PLASMA, EvolutionType.BLASTER_SCATTER],
            MISSILE: [EvolutionType.MISSILE_NAPALM, EvolutionType.MISSILE_SWARM],
            FREEZE: [EvolutionType.FREEZE_PERMA, EvolutionType.FREEZE_BLIZZARD],
            SHOCK: [EvolutionType.SHOCK_OVERLOAD, EvolutionType.SHOCK_STORM]
        };
        // EVOLUTION_STATS: UI-facing info and costs for evolution buttons.
        // TURRET_STATS: full gameplay stats for evolved types (created via makeTurret, same as base types).
        const EVOLUTION_STATS = {
            [EvolutionType.BLASTER_PLASMA]: {
                name: 'Plasma Cannon',
                cost: 2000,
                color: '#a855f7',
                desc: 'Piercing plasma bolts'
            },
            [EvolutionType.BLASTER_SCATTER]: {
                name: 'Scatter Gun',
                cost: 1800,
                color: '#f97316',
                desc: '5-shot spread'
            },
            [EvolutionType.MISSILE_NAPALM]: {
                name: 'Napalm Launcher',
                cost: 3600,
                color: '#dc2626',
                desc: 'Leaves fire trails'
            },
            [EvolutionType.MISSILE_SWARM]: {
                name: 'Swarm Pods',
                cost: 3000,
                color: '#84cc16',
                desc: '4 mini-missiles'
            },
            [EvolutionType.FREEZE_PERMA]: {
                name: 'Permafrost',
                cost: 3000,
                color: '#0ea5e9',
                desc: 'Near-total freeze'
            },
            [EvolutionType.FREEZE_BLIZZARD]: {
                name: 'Blizzard',
                cost: 2400,
                color: '#e0f2fe',
                desc: 'Massive slow area'
            },
            [EvolutionType.SHOCK_OVERLOAD]: {
                name: 'Overload',
                cost: 3200,
                color: '#fbbf24',
                desc: 'Longer stuns'
            },
            [EvolutionType.SHOCK_STORM]: {
                name: 'Thunder Storm',
                cost: 3000,
                color: '#6366f1',
                desc: 'Damages all stunned'
            }
        };

        const TargetingMode = {
            CLOSEST: 'CLOSEST',
            FIRST: 'FIRST',
            LAST: 'LAST',
            STRONG: 'STRONG',
            WEAK: 'WEAK'
        };

        const CoreWeaponType = {
            BLASTER: 'BLASTER',
            LASER: 'LASER',
            SWARM: 'SWARM'
        };

        const CoreModuleType = {
            ICE_SHELL: 'ICE_SHELL',
            REPAIR_NANOBOTS: 'REPAIR_NANOBOTS'
        };

        // ==================== GAME CONSTANTS & CONFIG ====================
        const GAME_CONSTANTS = {
            ENEMY_SYSTEM_CAPACITY: 2000,
            PARTICLE_SYSTEM_CAPACITY: 8000,
            TURRET_DEFAULT_HP: 100,
            TURRET_DEFAULT_RADIUS: 20,
            SELL_REFUND_RATIO: 0.5,
            SLOW_FACTOR_DEFAULT: 0.5,
            SLOW_FACTOR_RESIST: 0.8,
            FREEZE_DURATION: 30,
            BURN_TICK_DAMAGE: 2,
            POISON_TICK_DAMAGE: 1.5,
            GRID_CELL_SIZE: 100,
            GRID_VISUAL_SIZE: 50,
            INITIAL_MONEY: 100,
            INITIAL_HEALTH: 100,
            CORE_RADIUS: 30,
            CORE_DAMAGE_REDUCTION_CAP: 0.5,
            BASE_DRAG_RADIUS: 100,
            DRAG_RADIUS_PER_LEVEL: 25,
            FIXED_TIMESTEP: 16.66,
            // Combat
            ARMOR_REDUCTION: 0.5,
            HOMING_TURN_RATE: 0.03,
            ENEMY_DAMAGE_TO_TURRET: 0.5,
            // Detection
            DODGER_DETECT_RADIUS_SQ: 6400,
            CORE_HOVER_RADIUS: 55
        };
        const COLORS = {
            // Core UI Colors
            WHITE: '#ffffff',
            CYAN: '#00d9ff',
            RED: '#ef4444',
            GREEN: '#10b981',
            YELLOW: '#f59e0b',
            BLUE: '#3b82f6',
            ORANGE: '#ff6b35',

            // Effect Colors
            FREEZE: '#b0e0e6',
            FIRE: '#ff6b35',
            POISON: '#22c55e',
            ACID: '#84cc16',

            // Status Colors
            DESTROYED: '#ef4444',
            HEAL: '#10b981',
            DAMAGE: '#ef4444',
            CRIT: '#fbbf24',

            // Misc
            SHIELD: '#b0e0e6',
            GOLD: '#ffd700'
        };
        const NeonButton = ({
            onClick,
            children,
            className = '',
            disabled = false,
            color = 'cyan',
            icon: Icon
        }) => {
            const colors = {
                cyan: 'bg-cyan-700 hover:bg-cyan-600 border-cyan-500 text-white',
                red: 'bg-red-600 hover:bg-red-500 border-red-500 text-white',
                slate: 'bg-slate-800 hover:bg-slate-700 border-slate-600 text-cyan-400',
                indigo: 'bg-indigo-600 hover:bg-indigo-500 border-indigo-500 text-white',
                emerald: 'bg-emerald-900/20 text-emerald-500 border-emerald-900', // For maxed state
                white: 'bg-white hover:bg-blue-50 text-black shadow-white/10' // For primary start button
            };
            const baseClass = "px-6 py-3 font-bold rounded uppercase tracking-wider transition-all flex items-center justify-center gap-2 border shadow-lg hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:scale-100";

            return (
                <button onClick={onClick} disabled={disabled} className={`${baseClass} ${colors[color] || colors.slate} ${className}`}>
                    {Icon && <Icon className="w-5 h-5" />}
                    {children}
                </button>
            );
        };

        const CloseButton = ({ onClick, className = '' }) => (
            <button onClick={onClick} className={`text-slate-500 hover:text-white transition-colors ${className}`}>
                <X className="w-6 h-6" />
            </button>
        );

        const CodexCard = ({ icon: Icon = Hexagon, title, description, colorClass = "bg-slate-800", iconBgClass = "bg-slate-700", children }) => (
            <div className={`p-4 rounded-lg border border-slate-700 ${colorClass}`}>
                <div className="flex gap-4 items-center mb-4">
                    <div>
                        <div className="font-bold text-white uppercase">{title}</div>
                        <div className="text-sm text-slate-400 leading-tight">{description}</div>
                    </div>
                </div>
                {children}
            </div>
        );
        const INITIAL_HEALTH = GAME_CONSTANTS.INITIAL_HEALTH;
        const INITIAL_MONEY = GAME_CONSTANTS.INITIAL_MONEY;
        const SELL_REFUND_RATIO = GAME_CONSTANTS.SELL_REFUND_RATIO;

        const BASE_DRAG_RADIUS = GAME_CONSTANTS.BASE_DRAG_RADIUS;
        const DRAG_RADIUS_PER_LEVEL = GAME_CONSTANTS.DRAG_RADIUS_PER_LEVEL;
        const CORE_HOVER_RADIUS = GAME_CONSTANTS.CORE_HOVER_RADIUS;

        const CORE_BASE_STATS = {
            range: 200,
            damage: 10,
            cooldown: 500
        };

        // Core upgrades - single source of truth with cost, description, and benefits
        const CORE_UPGRADES = [
            {
                cost: 0,
                description: "Base Level",
                benefits: ["Standard Operations"]
            },
            {
                cost: 500,
                description: "Overclock Aura",
                benefits: ["All Turrets +15% Fire Rate"]
            },
            {
                cost: 1000,
                description: "Reinforced Hull",
                benefits: ["Core Damage Taken -20%"]
            },
            {
                cost: 2500,
                description: "Command Link",
                benefits: ["Global Range +20%"]
            },
            {
                cost: 5000,
                description: "Omega Weapon",
                benefits: ["Unlocks Core Armory"]
            },
            {
                cost: 10000,
                description: "Prismatic Core",
                benefits: ["Unlocks Elemental Augments"]
            }
        ];
        const CORE_UPGRADE_COSTS = CORE_UPGRADES.map(u => u ? u.cost : 0);


        const CORE_WEAPON_DEFS = {
            [CoreWeaponType.BLASTER]: {
                name: "Plasma Repeater",
                description: "Balanced rapid fire projectile weapon.",
                ultimateName: "OVERCLOCK",
                ultimateDesc: "Fire Rate +400% for 5s."
            },
            [CoreWeaponType.LASER]: {
                name: "Ion Beam",
                description: "Instant hit scan. Pierces all enemies in line.",
                ultimateName: "ORBITAL RAY",
                ultimateDesc: "Massive beam wipes a large area."
            },
            [CoreWeaponType.SWARM]: {
                name: "Nano Swarm",
                description: "Launches homing missiles at random targets.",
                ultimateName: "HUNTER CLOUD",
                ultimateDesc: "Launch 40 missiles instantly."
            }
        };
        const CORE_MODULE_DEFS = {
            [CoreModuleType.ICE_SHELL]: {
                name: "Cryo-Shield",
                description: "Negates 1 hit. Recharges every 20s. Freezes enemies on break.",
                cooldown: 20000,
                cost: 1500
            },
            [CoreModuleType.REPAIR_NANOBOTS]: {
                name: "Auto-Repair",
                description: "Restores 50 HP instantly. Passive regen +1/s.",
                cooldown: 60000,
                cost: 1500
            }
        };

        const COLOR_PALETTE = {
            background: '#050505',
            core: '#0ea5e9',
            coreDamaged: '#ef4444',
            text: '#f0f9ff',
            grid: '#1e293b',
            acid: '#84cc16'
        };
        const Vec = {
            distSq: (a, b) => (b.x - a.x) ** 2 + (b.y - a.y) ** 2
        };
        const isAreaTurret = (type) => type === TurretType.FREEZE || type === TurretType.AOE || type === TurretType.GRAVITY_WELL || type === EvolutionType.FREEZE_PERMA || type === EvolutionType.FREEZE_BLIZZARD;

        const SPRITE_URLS = {
            SNOWFLAKE: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTYiIGhlaWdodD0iMjU2IiB2aWV3Qm94PSIwIDAgMjQgMjQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzA2YjRkMyIgc3Ryb2tlLXdpZHRoPSIxLjI1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXNub3dmbGFrZS1pY29uIGx1Y2lkZS1zbm93Zmxha2UiPjxwYXRoIGQ9Im0xMCAyMC0xLjI1LTIuNUw2IDE4Ii8+PHBhdGggZD0iTTEwIDQgOC43NSA2LjUgNiA2Ii8+PHBhdGggZD0ibTE0IDIwIDEuMjUtMi41TDE4IDE4Ii8+PHBhdGggZD0ibTE0IDQgMS4yNSAyLjVMMTggNiIvPjxwYXRoIGQ9Im0xNyAyMS0zLTZoLTQiLz48cGF0aCBkPSJtMTcgMy0zIDYgMS41IDMiLz48cGF0aCBkPSJNMiAxMmg2LjVMMTAgOSIvPjxwYXRoIGQ9Im0yMCAxMC0xLjUgMiAxLjUgMiIvPjxwYXRoIGQ9Ik0yMiAxMmgtNi41TDE0IDE1Ii8+PHBhdGggZD0ibTQgMTAgMS41IDJMNCAxNCIvPjxwYXRoIGQ9Im03IDIxIDMtNi0xLjUtMyIvPjxwYXRoIGQ9Im03IDMgMyA2aDQiLz48L3N2Zz4=',
            BIOHAZARD: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTYiIGhlaWdodD0iMjU2IiB2aWV3Qm94PSIwIDAgMjQgMjQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzgwY2ExNSIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLWJpb2hhemFyZC1pY29uIGx1Y2lkZS1iaW9oYXphcmQiPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTEuOSIgcj0iMiIvPjxwYXRoIGQ9Ik02LjcgMy40Yy0uOSAyLjUgMCA1LjIgMi4yIDYuN0M2LjUgOSAzLjcgOS42IDIgMTEuNiIvPjxwYXRoIGQ9Im04LjkgMTAuMSAxLjQuOCIvPjxwYXRoIGQ9Ik0xNy4zIDMuNGMuOSAyLjUgMCA1LjItMi4yIDYuNyAyLjQtMS4yIDUuMi0uNiA2LjkgMS41Ii8+PHBhdGggZD0ibTE1LjEgMTAuMS0xLjQuOCIvPjxwYXRoIGQ9Ik0xNi43IDIwLjhjLTIuNi0uNC00LjYtMi42LTQuNy01LjMtLjIgMi42LTIuMSA0LjgtNC43IDUuMiIvPjxwYXRoIGQ9Ik0xMiAxMy45djEuNiIvPjxwYXRoIGQ9Ik0xMy41IDUuNGMtMS0uMi0yLS4yLTMgMCIvPjxwYXRoIGQ9Ik0xNyAxNi40Yy43LS43IDEuMi0xLjYgMS41LTIuNSIvPjxwYXRoIGQ9Ik01LjUgMTMuOWMuMy45LjggMS44IDEuNSAyLjUiLz48L3N2Zz4=',
            ROCKET: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTYiIGhlaWdodD0iMjU2IiB2aWV3Qm94PSIwIDAgMjQgMjQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzA2YjRkMyIgc3Ryb2tlLXdpZHRoPSIxLjI1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXJvY2tldC1pY29uIGx1Y2lkZS1yb2NrZXQiPjxwYXRoIGQ9Ik00LjUgMTYuNWMtMS41IDEuMjYtMiA1LTIgNXMzLjc0LS41IDUtMmMuNzEtLjg0LjctMi4xMy0uMDktMi45MWEyLjE4IDIuMTggMCAwIDAtMi45MS0uMDl6Ii8+PHBhdGggZD0ibTEyIDE1LTMtM2EyMiAyMiAwIDAgMSAyLTMuOTVBMTIuODggMTIuODggMCAwIDEgMjIgMmMwIDIuNzItLjc4IDcuNS02IDExYTIyLjM1IDIyLjM1IDAgMCAxLTQgMnoiLz48cGF0aCBkPSJNOSAxMkg0cy41NS0zLjAzIDItNGMxLjYyLTEuMDggNSAwIDUgMCIvPjxwYXRoIGQ9Ik0xMiAxNXY1czMuMDMtLjU1IDQtMmMxLjA4LTEuNjIgMC01IDAtNSIvPjwvc3ZnPg=='
        };
        const TURRET_SHAPES = {
            SNIPER: {
                type: 'rect',
                args: [-10, -10, 20, 20]
            },
            AOE: {
                type: 'poly',
                points: [
                    [0, -12],
                    [12, 0],
                    [0, 12],
                    [-12, 0]
                ]
            }, // Diamond
            RAPID: {
                type: 'poly',
                points: [
                    [0, -12],
                    [11, -4],
                    [7, 10],
                    [-7, 10],
                    [-11, -4]
                ]
            }, // Pentagon
            FREEZE: {
                type: 'sprite',
                src: SPRITE_URLS.SNOWFLAKE
            },
            SHOCK: {
                type: 'poly',
                points: [
                    [0, -14],
                    [5, -5],
                    [14, 0],
                    [5, 5],
                    [0, 14],
                    [-5, 5],
                    [-14, 0],
                    [-5, -5]
                ]
            },
            FLAMETHROWER: {
                type: 'poly',
                points: [
                    [0, -14],
                    [10, -4],
                    [8, 6],
                    [0, 14],
                    [-8, 6],
                    [-10, -4]
                ]
            },
            MISSILE: {
                type: 'sprite',
                src: SPRITE_URLS.ROCKET
            },
            PRISM: {
                type: 'poly',
                points: [
                    [0, -14],
                    [12, -7],
                    [12, 7],
                    [0, 14],
                    [-12, 7],
                    [-12, -7]
                ]
            },
            CANNON: {
                type: 'rect',
                args: [-12, -8, 24, 16]
            },
            ACID: {
                type: 'sprite',
                src: SPRITE_URLS.BIOHAZARD
            },
            RAILGUN: { type: 'custom' },
            GRAVITY_WELL: {
                type: 'custom',
                drawStyle: 'unfilled_circle'
            },
            DEFAULT: {
                type: 'poly',
                points: [
                    [0, -10],
                    [10, 5],
                    [-10, 5]
                ]
            }
        };

        const hexToNum = (hex) => {
            if (typeof hex === 'number') return hex;
            if (!hex || typeof hex !== 'string') return 0x22d3ee;
            return parseInt(hex.replace('#', ''), 16);
        };

        const numToHex = (num) => {
            if (typeof num === 'string') return num;
            return '#' + num.toString(16).padStart(6, '0');
        };

        const RenderSystem = {
            hexToNum,
            Drawers: {
                progressBar: (g, x, y, w, h, val, max, bg, fill) => {
                    g.rect(x, y, w, h).fill(bg);
                    if (val > 0) g.rect(x, y, w * Math.min(1, val / max), h).fill(fill);
                },
                armoredRing: (g, r, rot) => { g.arc(0, 0, r + 6, rot, rot + Math.PI * 1.5).stroke({ width: 2, color: 0x94a3b8 }); },
                frozenRing: (g, r) => { g.circle(0, 0, r).stroke({ width: 2, color: 0x06b6d4 }); },
                burningRing: (g, r) => {
                    for (let i = 0; i < 8; i++) g.arc(0, 0, r + 1, i * Math.PI / 4, i * Math.PI / 4 + Math.PI / 8);
                    g.stroke({ width: 2, color: 0xf97316 });
                },
                poisonDot: (g, r) => { g.circle(r * 0.7, -r * 0.7, 4).fill(0x84cc16); },
                levelPips: (c, lvl, tex, sp = 6, y = -16) => {
                    while (c.children.length < lvl) { c.addChild(new PIXI.Sprite(tex)).anchor.set(0.5); }
                    c.children.forEach((p, i) => { p.visible = i < lvl; if (p.visible) { p.x = -8 + i * sp; p.y = y; } });
                },
                resistSlowArrow: (g, r, ang) => {
                    const ax = Math.cos(ang + Math.PI) * (r + 6), ay = Math.sin(ang + Math.PI) * (r + 6);
                    g.moveTo(ax, ay - 4).lineTo(ax + 4, ay).lineTo(ax, ay + 4).closePath().fill(0xfca5a5);
                },
                resistStunStar: (g, r, rot) => {
                    for (let k = 0; k < 5; k++) {
                        const ka = k * Math.PI * 0.4 + rot;
                        g.moveTo(0, 0).lineTo(Math.cos(ka) * (r + 4), Math.sin(ka) * (r + 4));
                    }
                    g.stroke({ width: 1, color: 0xfde047 });
                },
                regenCross: (g, r, pulse) => { if (pulse > 0.7) g.rect(r - 2, -r - 6, 8, 2).rect(r + 1, -r - 9, 2, 8).fill(0x86efac); },
                rangeCircle: (g, x, y, r, c, a = 0.1) => g.circle(x, y, r).fill({ color: c, alpha: a }).circle(x, y, r).stroke({ width: 1, color: c, alpha: a * 3 })
            },

            createEntityContainer: (labels) => {
                const container = new PIXI.Container();
                labels.forEach(label => {
                    const g = new PIXI.Graphics();
                    g.label = label;
                    container.addChild(g);
                    container[label] = g;
                });
                return container;
            },

            drawShape: (g, shapeData) => {
                if (shapeData.type === 'rect') g.rect(...shapeData.args);
                else if (shapeData.type === 'circle') g.circle(...shapeData.args);
                else if (shapeData.type === 'poly') {
                    shapeData.points.forEach((p, i) => i === 0 ? g.moveTo(p[0], p[1]) : g.lineTo(p[0], p[1]));
                    g.closePath();
                }
            },

            syncPool: (pool, aliveIds, layer, destroyFn) => {
                for (const [id, obj] of pool.entries()) {
                    if (!aliveIds.has(id)) {
                        layer.removeChild(obj);
                        destroyFn ? destroyFn(obj) : obj.destroy({ children: true });
                        pool.delete(id);
                    }
                }
            },

            getTurretTexture: (type, colorHex, textures, app) => {
                const key = `${type}_${colorHex}`;
                if (textures.turrets.has(key)) return textures.turrets.get(key);
                if (!app) return null;

                // Find base type for evolutions to retain shape
                let baseShapeType = type;
                if (!TURRET_SHAPES[type]) {
                    for (const [base, evos] of Object.entries(EVOLUTION_PATHS)) {
                        if (evos.includes(type)) { baseShapeType = base; break; }
                    }
                }

                const shapeData = TURRET_SHAPES[baseShapeType] || TURRET_SHAPES.DEFAULT;
                if (shapeData.type === 'sprite') return null;

                const g = new PIXI.Graphics();
                const color = RenderSystem.hexToNum(colorHex);

                if (shapeData.type === 'custom') {
                    if (baseShapeType === TurretType.RAILGUN) {
                        g.rect(-14, -6, 28, 12).fill(color).rect(-10, -2, 20, 4).fill(0x000000);
                    } else if (baseShapeType === TurretType.GRAVITY_WELL) {
                        g.circle(0, 0, 14).stroke({ width: 3, color }).circle(0, 0, 8).stroke({ width: 2, color, alpha: 0.5 });
                    } else { g.circle(0, 0, 10).fill(color); }
                } else {
                    RenderSystem.drawShape(g, shapeData);
                    g.fill(color);
                }

                // Add electrified effect for evolved SHOCK turrets
                if (type === EvolutionType.SHOCK_OVERLOAD || type === EvolutionType.SHOCK_STORM) {
                    const sparkColor = type === EvolutionType.SHOCK_OVERLOAD ? 0xfbbf24 : 0x818cf8;
                    // Draw little jagged lines around the core shape
                    g.moveTo(0, -12).lineTo(5, -18).lineTo(2, -22).stroke({ width: 3, color: sparkColor });
                    g.moveTo(0, 12).lineTo(-5, 18).lineTo(-2, 22).stroke({ width: 3, color: sparkColor });
                    g.moveTo(12, 0).lineTo(18, -5).lineTo(22, -2).stroke({ width: 3, color: sparkColor });
                    g.moveTo(-12, 0).lineTo(-18, 5).lineTo(-22, 2).stroke({ width: 3, color: sparkColor });
                    // Thin inner glow ring
                    g.circle(0, 0, 10).stroke({ width: 2, color: sparkColor, alpha: 0.8 });
                }

                const texture = app.renderer.generateTexture(g);
                textures.turrets.set(key, texture);
                g.destroy();
                return texture;
            },

            getEnemyTexture: (type, colorHex, radius, textures, app) => {
                const key = `${type}_${colorHex}_${radius} `;
                if (textures.enemies.has(key)) return textures.enemies.get(key);
                if (!app) return null;

                const g = new PIXI.Graphics();
                const color = RenderSystem.hexToNum(colorHex);

                if (type === EnemyType.BOSS || type === EnemyType.MINIBOSS) {
                    for (let i = 0; i < 6; i++) {
                        const a = i * Math.PI / 3;
                        i === 0 ? g.moveTo(Math.cos(a) * radius, Math.sin(a) * radius) : g.lineTo(Math.cos(a) * radius, Math.sin(a) * radius);
                    }
                    g.closePath();
                } else if (type === EnemyType.SPLITTER) {
                    g.rect(-radius, -radius, radius * 2, radius * 2);
                } else {
                    g.circle(0, 0, radius);
                }
                const texture = app.renderer.generateTexture(g.fill(color));
                textures.enemies.set(key, texture);
                g.destroy();
                return texture;
            },

            getProjectileTexture: (shape, colorHex, radius, textures, app) => {
                const key = `${shape}_${colorHex}_${radius} `;
                if (textures.projectiles.has(key)) return textures.projectiles.get(key);
                if (!app) return null;
                const g = new PIXI.Graphics();
                switch (shape) {
                    case 'ROCKET': g.moveTo(10, 0).lineTo(-4, 6).lineTo(-4, -6).closePath(); break;
                    case 'LINE': g.rect(-6, -1, 12, 2); break;
                    case 'GLOB': g.circle(0, 0, radius).circle(-2, -2, radius / 2); break;
                    default: g.circle(0, 0, radius); break;
                }
                const texture = app.renderer.generateTexture(g.fill(RenderSystem.hexToNum(colorHex)));
                textures.projectiles.set(key, texture);
                g.destroy();
                return texture;
            },

            getPipTexture: (textures, app) => {
                if (textures.pip) return textures.pip;
                if (!app) return null;
                const g = new PIXI.Graphics();
                g.circle(0, 0, 2).fill(0xffffff);
                textures.pip = app.renderer.generateTexture(g);
                g.destroy();
                return textures.pip;
            },

            getCoreTexture: (colorHex, textures, app) => {
                if (textures.core.has(colorHex)) return textures.core.get(colorHex);
                if (!app) return null;
                const g = new PIXI.Graphics();
                const color = RenderSystem.hexToNum(colorHex);
                g.circle(0, 0, 30).fill(color);
                g.circle(0, 0, 30).stroke({ width: 3, color: 0xffffff });
                const texture = app.renderer.generateTexture(g);
                textures.core.set(colorHex, texture);
                g.destroy();
                return texture;
            },

            getCoreGlowTexture: (colorHex, textures) => {
                if (textures.coreGlow.has(colorHex)) return textures.coreGlow.get(colorHex);
                const size = 120, h = size / 2;
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = size;
                const ctx = canvas.getContext('2d');
                const grad = ctx.createRadialGradient(h, h, 10, h, h, h);
                grad.addColorStop(0, colorHex);
                grad.addColorStop(1, 'transparent');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, size, size);
                const texture = PIXI.Texture.from(canvas);
                textures.coreGlow.set(colorHex, texture);
                return texture;
            },

            getRangeTexture: (radius, colorHex, textures) => {
                const key = `${radius}_${colorHex}`;
                if (!textures.ranges) textures.ranges = new Map();
                if (textures.ranges.has(key)) return textures.ranges.get(key);

                const padding = 4;
                const size = (radius + padding) * 2;
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = size;
                const ctx = canvas.getContext('2d');
                const center = size / 2;

                const hexNum = typeof colorHex === 'number'
                    ? colorHex
                    : parseInt(String(colorHex).replace('#', ''), 16);
                const r = (hexNum >> 16) & 255, g = (hexNum >> 8) & 255, b = hexNum & 255;

                ctx.fillStyle = `rgba(${r},${g},${b},0.08)`;
                ctx.beginPath();
                ctx.arc(center, center, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = `rgba(${r},${g},${b},0.3)`;
                ctx.lineWidth = 2;
                ctx.stroke();

                const texture = PIXI.Texture.from(canvas);
                textures.ranges.set(key, texture);
                return texture;
            },

            renderEntity: (container, entity, schemaType, context) => {
                const { state, dims, getTexture, getPipTexture, EnemyTrait } = context;
                container.position.set(entity.x, entity.y);
                if (entity.angle !== undefined) container.rotation = entity.angle;

                const get = (lbl, Type = PIXI.Graphics) => {
                    let o = container[lbl] || container.getChildByLabel?.(lbl);
                    if (!o) { o = new Type(); o.label = lbl; if (Type === PIXI.Sprite) o.anchor.set(0.5); container.addChild(o); container[lbl] = o; }
                    return o;
                };

                if (schemaType === 'ENEMY') {
                    const sprite = get('shapeSprite', PIXI.Sprite), tex = getTexture?.('enemy', entity);
                    if (tex && sprite.texture !== tex) sprite.texture = tex;

                    const status = get('status'); status.clear();
                    [['frozen', 'frozenRing'], ['burn', 'burningRing'], ['poison', 'poisonDot']].forEach(([k, f]) => (entity[k] > 0) && RenderSystem.Drawers[f](status, entity.radius));

                    const hp = get('health');
                    if (hp._lastHp !== entity.hp) {
                        hp._lastHp = entity.hp; hp.clear();
                        if (entity.hp < entity.maxHp) RenderSystem.Drawers.progressBar(hp, -10, -entity.radius - 8, 20, 4, entity.hp, entity.maxHp, 0x1e293b, entity.hp / entity.maxHp > 0.5 ? 0x22c55e : 0xef4444);
                    }
                    hp.visible = entity.hp < entity.maxHp;

                    const traits = get('traits'); traits.clear();
                    if (entity.traits?.length) {
                        const T = RenderSystem.Drawers, r = entity.radius;
                        if (entity.traits.includes(EnemyTrait.ARMORED)) T.armoredRing(traits, r, state.gameTime * 0.005);
                        if (entity.traits.includes(EnemyTrait.RESIST_SLOW)) T.resistSlowArrow(traits, r, Math.atan2(dims.h / 2 - entity.y, dims.w / 2 - entity.x));
                        if (entity.traits.includes(EnemyTrait.RESIST_STUN)) T.resistStunStar(traits, r, state.gameTime * 0.005);
                        if (entity.traits.includes(EnemyTrait.REGEN)) T.regenCross(traits, r, Math.abs(Math.sin(state.gameTime * 0.01)));
                    }
                } else if (schemaType === 'TURRET') {
                    const sprite = get('shapeSprite', PIXI.Sprite), shape = TURRET_SHAPES[entity.type] || TURRET_SHAPES.DEFAULT;
                    if (shape.type === 'sprite' && shape.src) {
                        if (sprite._src !== shape.src) {
                            const img = new Image(); img.src = shape.src; img.onload = () => sprite.texture = PIXI.Texture.from(img);
                            sprite._src = shape.src; sprite.scale.set(30 / 256);
                        }
                        sprite.tint = RenderSystem.hexToNum(entity.color);
                    } else {
                        const tex = getTexture?.('turret', entity);
                        if (tex && sprite.texture !== tex) sprite.texture = tex;
                    }

                    const charge = get('chargeBar');
                    if (entity.type === 'RAILGUN' && entity.charge !== undefined) {
                        if (charge._last !== entity.charge) { charge._last = entity.charge; charge.clear(); RenderSystem.Drawers.progressBar(charge, -12, 15, 24, 4, entity.charge, 100, 0, 0x22d3ee); }
                        charge.visible = true;
                    } else charge.visible = false;


                } else if (schemaType === 'PROJECTILE') {
                    if (context.glowTexture) {
                        const glow = get('glowSprite', PIXI.Sprite);
                        if (glow.texture !== context.glowTexture) glow.texture = context.glowTexture;
                        glow.tint = RenderSystem.hexToNum?.(entity.color) || 0xffffff; glow.blendMode = 'add';
                        glow.width = glow.height = entity.radius * 8;
                        if (entity.shape === 'LINE') { glow.width = entity.radius * 16; glow.height = entity.radius * 6; }
                    }
                    const sprite = get('shapeSprite', PIXI.Sprite), tex = getTexture?.('projectile', entity);
                    if (tex && sprite.texture !== tex) sprite.texture = tex;
                }
            }
        };

        // ==================== DATA TABLES (TURRET STATS, COSTS, ABILITIES) ====================
        const makeTurret = ({
            name,
            icon,
            cost,
            range,
            damage,
            cooldown,
            color,
            category,
            description,
            stats,
            specialEffect,
            ...extra
        }) => ({
            name,
            icon,
            cost,
            range,
            damage,
            cooldown,
            color,
            category,
            description,
            stats,
            specialEffect,
            ...extra
        });

        // @turret-data — All turret definitions in one table. Change structure here.
        // Fields: [type, { name, icon, cost, range, damage, cooldown, color, category, description, stats, specialEffect, ...extras }]
        const TURRET_DATA = [
            // ---- KINETIC ----
            [TurretType.BLASTER, {
                name: 'Blaster',
                icon: Circle,
                color: '#3b82f6',
                category: 'KINETIC',
                cost: 50,
                range: 150,
                damage: 10,
                cooldown: 400,
                description: "Rapid fire, short range.",
                stats: {
                    damage: 3,
                    range: 3,
                    speed: 7
                },
                specialEffect: "Pierce Chance"
            }],
            [TurretType.SNIPER, {
                name: 'Sniper',
                icon: Crosshair,
                color: '#a855f7',
                category: 'KINETIC',
                cost: 120,
                range: 400,
                damage: 50,
                cooldown: 1500,
                description: "Long range, high damage.",
                stats: {
                    damage: 9,
                    range: 10,
                    speed: 8
                },
                specialEffect: "Kill Buff"
            }],
            [TurretType.RAPID, {
                name: 'Minigun',
                icon: Grip,
                color: '#f97316',
                category: 'KINETIC',
                cost: 300,
                range: 140,
                damage: 4,
                cooldown: 60,
                description: "Extreme fire rate, low dmg.",
                stats: {
                    damage: 2,
                    range: 3,
                    speed: 10
                },
                specialEffect: "Rate Ramp"
            }],
            [TurretType.CANNON, {
                name: 'Cannon',
                icon: Database,
                color: '#78716c',
                category: 'KINETIC',
                cost: 200,
                range: 180,
                damage: 35,
                cooldown: 1200,
                description: "Heavy hitter. Pushes enemies back.",
                stats: {
                    damage: 8,
                    range: 4,
                    speed: 2
                },
                specialEffect: "+50% Knockback",
                knockback: 40
            }],

            // ---- ELEMENTAL ----
            [TurretType.FLAMETHROWER, {
                name: 'Plasma Vent',
                icon: Flame,
                color: '#f43f5e',
                category: 'ELEMENTAL',
                cost: 350,
                range: 120,
                damage: 1,
                cooldown: 70,
                description: "Burns enemies. COMBO: Poison",
                stats: {
                    damage: 2,
                    range: 2,
                    speed: 10
                },
                specialEffect: "Blue Flame"
            }],
            [TurretType.FREEZE, {
                name: 'Cryo Field',
                icon: Snowflake,
                color: '#06b6d4',
                category: 'ELEMENTAL',
                cost: 300,
                range: 180,
                damage: 0.5,
                cooldown: 10,
                description: "Aura slows enemies. COMBO: Fire/Shock",
                stats: {
                    damage: 1,
                    range: 4,
                    speed: 10
                },
                specialEffect: "Deep Freeze"
            }],
            [TurretType.SHOCK, {
                name: 'Tesla Coil',
                icon: Zap,
                color: '#e879f9',
                category: 'ELEMENTAL',
                cost: 400,
                range: 160,
                damage: 15,
                cooldown: 1000,
                description: "Chains. COMBO: Frozen/Poison",
                stats: {
                    damage: 6,
                    range: 4,
                    speed: 4
                },
                specialEffect: "Combo: Frozen"
            }],
            [TurretType.ACID, {
                name: 'Acid Spitter',
                icon: Biohazard,
                color: '#84cc16',
                category: 'ELEMENTAL',
                cost: 250,
                range: 200,
                damage: 5,
                cooldown: 600,
                description: "Applies Poison DoT. COMBO: Fire/Shock",
                stats: {
                    damage: 2,
                    range: 5,
                    speed: 6
                },
                specialEffect: "Stacks Poison"
            }],

            // ---- HEAVY ----
            [TurretType.AOE, {
                name: 'Shockwave',
                icon: Activity,
                color: '#f59e0b',
                category: 'HEAVY',
                cost: 200,
                range: 100,
                damage: 1,
                cooldown: 150,
                description: "Continuous area damage.",
                stats: {
                    damage: 4,
                    range: 2,
                    speed: 10
                },
                specialEffect: "Stun Chance"
            }],
            [TurretType.MISSILE, {
                name: 'Rocket',
                icon: Bomb,
                color: '#ef4444',
                category: 'HEAVY',
                cost: 550,
                range: 300,
                damage: 40,
                cooldown: 2000,
                description: "Explodes on impact.",
                stats: {
                    damage: 8,
                    range: 8,
                    speed: 1
                },
                specialEffect: "Napalm"
            }],
            [TurretType.GRAVITY_WELL, {
                name: 'Gravity Well',
                icon: Target,
                color: '#6366f1',
                category: 'HEAVY',
                cost: 400,
                range: 150,
                damage: 3,
                cooldown: 100,
                description: "Slows enemies moving away. Low damage.",
                stats: {
                    damage: 1,
                    range: 4,
                    speed: 8
                },
                specialEffect: "+Pull strength",
                slowFactor: 0.4
            }],
            [TurretType.RAILGUN, {
                name: 'Railgun',
                icon: Divide,
                color: '#22d3ee',
                category: 'HEAVY',
                cost: 800,
                range: 1200,
                damage: 500,
                cooldown: 3000,
                description: "Charges up massive beam.",
                stats: {
                    damage: 10,
                    range: 10,
                    speed: 10
                },
                specialEffect: "Pierces All"
            }],

            // ---- SUPPORT ----
            [TurretType.PRISM, {
                name: 'Prism',
                icon: Hexagon,
                color: '#d946ef',
                category: 'SUPPORT',
                cost: 500,
                range: 150,
                damage: 0,
                cooldown: 0,
                description: "Buffs Fire Rate/Range of neighbors.",
                stats: {
                    damage: 0,
                    range: 5,
                    speed: 0
                },
                specialEffect: "Stacks 2x"
            }],

            // ---- EVOLVED TURRETS ----
            [EvolutionType.BLASTER_PLASMA, {
                name: 'Plasma Cannon',
                icon: Circle,
                color: '#a855f7',
                category: 'KINETIC',
                cost: 0,
                range: 160,
                damage: 25,
                cooldown: 500,
                description: "High-damage piercing shots.",
                stats: {
                    damage: 8,
                    range: 4,
                    speed: 8
                },
                displayStats: { damage: "25", range: "160", speed: "2.0/s" },
                specialEffect: "Pierce All",
                pierce: true
            }],
            [EvolutionType.BLASTER_SCATTER, {
                name: 'Scatter Gun',
                icon: Circle,
                color: '#f97316',
                category: 'KINETIC',
                cost: 0,
                range: 120,
                damage: 8,
                cooldown: 600,
                description: "5-shot spread. Short range.",
                stats: {
                    damage: 3,
                    range: 2,
                    speed: 7
                },
                displayStats: { damage: "8 x 5", range: "120", speed: "1.6/s" },
                specialEffect: "5 Projectiles",
                projectileCount: 5
            }],
            [EvolutionType.MISSILE_NAPALM, {
                name: 'Napalm',
                icon: Bomb,
                color: '#dc2626',
                category: 'HEAVY',
                cost: 0,
                range: 280,
                damage: 30,
                cooldown: 2200,
                description: "Leaves burning ground.",
                stats: {
                    damage: 6,
                    range: 7,
                    speed: 1
                },
                displayStats: { damage: "30 + Burn", range: "280", speed: "0.4/s" },
                specialEffect: "Fire Trail",
                burnOnImpact: true
            }],
            [EvolutionType.MISSILE_SWARM, {
                name: 'Swarm Pods',
                icon: Bomb,
                color: '#84cc16',
                category: 'HEAVY',
                cost: 0,
                range: 250,
                damage: 12,
                cooldown: 1200,
                description: "Fires 4 mini-missiles.",
                stats: {
                    damage: 3,
                    range: 6,
                    speed: 1
                },
                displayStats: { damage: "12 x 4", range: "250", speed: "0.8/s" },
                specialEffect: "4 Missiles",
                projectileCount: 4
            }],
            [EvolutionType.FREEZE_PERMA, {
                name: 'Permafrost',
                icon: Snowflake,
                color: '#0ea5e9',
                category: 'ELEMENTAL',
                cost: 0,
                range: 140,
                damage: 1,
                cooldown: 10,
                description: "Near-total freeze.",
                stats: {
                    damage: 1,
                    range: 3,
                    speed: 10
                },
                displayStats: { damage: "Low", range: "140", speed: "Continuous" },
                specialEffect: "90% Slow",
                slowMult: 0.9
            }],
            [EvolutionType.FREEZE_BLIZZARD, {
                name: 'Blizzard',
                icon: Snowflake,
                color: '#e0f2fe',
                category: 'ELEMENTAL',
                cost: 0,
                range: 280,
                damage: 0.5,
                cooldown: 10,
                description: "Massive slow area.",
                stats: {
                    damage: 1,
                    range: 7,
                    speed: 10
                },
                displayStats: { damage: "Low", range: "280", speed: "Continuous" },
                specialEffect: "Huge Range",
                slowMult: 0.4
            }],
            [EvolutionType.SHOCK_OVERLOAD, {
                name: 'Overload',
                icon: Zap,
                color: '#fbbf24',
                category: 'ELEMENTAL',
                cost: 0,
                range: 150,
                damage: 20,
                cooldown: 1200,
                description: "Long stun duration.",
                stats: {
                    damage: 6,
                    range: 4,
                    speed: 4
                },
                displayStats: { damage: "20", range: "150", speed: "0.8/s" },
                specialEffect: "2s Stun",
                stunDuration: 120
            }],
            [EvolutionType.SHOCK_STORM, {
                name: 'Thunder Storm',
                icon: Zap,
                color: '#6366f1',
                category: 'ELEMENTAL',
                cost: 0,
                range: 180,
                damage: 10,
                cooldown: 800,
                description: "Damages all stunned.",
                stats: {
                    damage: 4,
                    range: 5,
                    speed: 5
                },
                displayStats: { damage: "10 AoE", range: "180", speed: "1.2/s" },
                specialEffect: "AoE Stun Dmg",
                aoeDamageToStunned: 0.5
            }],
        ];

        // Build TURRET_STATS from TURRET_DATA table
        const TURRET_STATS = TURRET_DATA.reduce((acc, [type, def]) => {
            acc[type] = makeTurret(def);
            return acc;
        }, {});

        // Factory helpers for CodexVisuals (reduces ~50 lines)
        const StatusIcon = (Icon, from, to, text, spin, extra) => (
            <div className="relative w-16 h-16 mx-auto">
                <div className={`absolute inset-0 rounded-full bg-gradient-to-br ${from} ${to} animate-pulse`}></div>
                <div className="absolute inset-1 rounded-full bg-slate-800 flex items-center justify-center">
                    <Icon className={`w-6 h-6 ${text}${spin ? ' animate-spin' : ''}`} style={spin ? { animationDuration: '3s' } : {}} />
                </div>
                {extra}
            </div>
        );
        const ComboIcon = (Icon1, bg1, Icon2, bg2) => (
            <div className="flex items-center justify-center gap-2">
                <div className={`w-10 h-10 rounded-full ${bg1} flex items-center justify-center border-2 border-slate-700`}><Icon1 className="text-white w-5 h-5" /></div>
                <span className="text-xl font-bold text-slate-500">+</span>
                <div className={`w-10 h-10 rounded-full ${bg2} flex items-center justify-center border-2 border-slate-700`}><Icon2 className="text-white w-5 h-5" /></div>
            </div>
        );

        const TraitVis = (bgFrom, bgTo, inner, extra) => (
            <div className="relative w-24 h-24 mx-auto">
                <div className={`absolute inset-4 rounded-full bg-gradient-to-br ${bgFrom} ${bgTo} shadow-lg shadow-red-500/50`}></div>
                {inner}
                {extra}
            </div>
        );
        const CodexVisuals = {
            BURNING: StatusIcon(Flame,
                'from-orange-400',
                'to-red-500',
                'text-orange-400'),
            PARALYSIS: StatusIcon(Zap,
                'from-yellow-400',
                'to-yellow-600',
                'text-yellow-400'),
            FROZEN: StatusIcon(Snowflake,
                'from-cyan-400',
                'to-blue-500',
                'text-cyan-400'),
            POISONED: StatusIcon(Biohazard,
                'from-lime-400',
                'to-green-600',
                'text-lime-400',
                true,
                <div className="absolute -top-1 -right-1 w-4 h-4 rounded-full bg-lime-500 animate-ping"></div>),
            THERMAL_SHOCK: ComboIcon(Snowflake,
                'bg-cyan-500',
                Flame,
                'bg-orange-500'),
            SUPERCONDUCTOR: ComboIcon(Snowflake,
                'bg-cyan-500',
                Zap,
                'bg-fuchsia-500'),
            COMBO_NOXIOUS: ComboIcon(Biohazard,
                'bg-lime-500',
                Flame,
                'bg-orange-500'),
            COMBO_PARALYSIS: ComboIcon(Biohazard,
                'bg-lime-500',
                Zap,
                'bg-fuchsia-500'),
            ARMORED: TraitVis('from-red-400',
                'to-red-600',
                <div className="absolute inset-0 rounded-full animate-pulse" style={{ background: 'radial-gradient(circle, rgba(148,163,184,0.3) 0%, transparent 70%)' }}></div>,
                <svg className="absolute inset-0 w-full h-full animate-spin" style={{ animationDuration: '4s', filter: 'drop-shadow(0 0 4px #94a3b8)' }}><circle cx="48" cy="48" r="42" fill="none" stroke="#94a3b8" strokeWidth="4" strokeDasharray="200 65" strokeLinecap="round" /></svg>),
            RESIST_SLOW: TraitVis('from-red-400',
                'to-red-600',
                null,
                <div className="absolute inset-0 flex items-center justify-end pr-0 animate-pulse">
                    <svg width="28" height="28" viewBox="0 0 24 24"
                        style={{ filter: 'drop-shadow(0 0 6px #fca5a5)' }}>
                        <polygon points="2,6 14,12 2,18" fill="#fca5a5" />
                        <polygon points="8,8 18,12 8,16" fill="#ef4444" />
                    </svg>
                </div>),
            REGENERATION: TraitVis('from-green-400',
                'to-green-600',
                <div className="absolute inset-0 animate-ping opacity-30 rounded-full bg-emerald-400" style={{ animationDuration: '3s' }}></div>,
                <><div className="absolute top-0 right-4 animate-bounce text-emerald-300 font-bold">+</div><div className="absolute bottom-4 left-4 animate-bounce text-emerald-300 font-bold" style={{ animationDelay: '0.5s' }}>+</div></>),
            SHIELDED: (
                <div className="relative w-24 h-24 mx-auto">
                    <div className="absolute inset-4 rounded-full bg-gradient-to-br from-cyan-400 to-blue-600" />
                    <div className="absolute inset-0 rounded-full border-4 border-cyan-400 opacity-70 animate-ping"
                        style={{ animationDuration: '3s' }} />
                    <div className="absolute inset-2 rounded-full border-2 border-cyan-200 opacity-50" />
                </div>
            )
        };

        const CODEX_DATA = {
            EFFECTS: [
                {
                    id: 'FROZEN',
                    title: 'FROZEN',
                    iconBgClass: 'bg-cyan-500',
                    icon: Snowflake,
                    description: "Slows enemy movement speed by 50-80%. Caused by Freeze turrets.",
                    visual: 'FROZEN'
                },
                {
                    id: 'BURNING',
                    title: 'BURNING',
                    iconBgClass: 'bg-orange-500',
                    icon: Flame,
                    description: "Deals damage over time. Caused by Plasma turrets. Combos with Poison!",
                    visual: 'BURNING'
                },
                {
                    id: 'POISONED',
                    title: 'POISONED',
                    iconBgClass: 'bg-lime-500',
                    icon: Biohazard,
                    description: "Stacking DoT. Acid turrets apply poison.",
                    visual: 'POISONED'
                },
                {
                    id: 'STUN',
                    title: 'STUNNED',
                    iconBgClass: 'bg-yellow-500',
                    icon: Zap,
                    description: "Enemy ignores movement and actions. Caused by Shock turrets or combos.",
                    visual: 'PARALYSIS'
                }
            ],
            COMBOS: [
                {
                    title: "THERMAL SHOCK",
                    icon: Flame,
                    iconBgClass: "bg-orange-500",
                    description: <span>Hitting <span className="text-cyan-400">Frozen</span> enemies with <span className="text-orange-400">Fire</span> deals <span className="text-white font-bold">30% Max HP</span> + <span className="text-white font-bold">150 AoE</span> damage.</span>,
                    visual: 'THERMAL_SHOCK'
                },
                {
                    title: "SUPERCONDUCTOR",
                    icon: Zap,
                    iconBgClass: "bg-fuchsia-500",
                    description: <span>Shocking <span className="text-cyan-400">Frozen</span> enemies creates chain lightning hitting <span className="text-white font-bold">5 targets</span> for <span className="text-white font-bold">25 DMG</span> each.</span>,
                    visual: 'SUPERCONDUCTOR'
                },
                {
                    title: "NOXIOUS CLOUD",
                    icon: Biohazard,
                    iconBgClass: "bg-lime-500",
                    description: <span>Igniting <span className="text-lime-400">Poisoned</span> enemies creates a gas cloud dealing <span className="text-white font-bold">20 DPS</span> for <span className="text-white font-bold">5s</span>.</span>,
                    visual: 'COMBO_NOXIOUS'
                },
                {
                    title: "PARALYSIS",
                    icon: Zap,
                    iconBgClass: "bg-yellow-500",
                    description: <span>Shocking <span className="text-lime-400">Poisoned</span> enemies applies <span className="text-white font-bold">STUN</span> for <span className="text-white font-bold">2s</span>.</span>,
                    visual: 'COMBO_PARALYSIS'
                }
            ],
            TRAITS: [
                {
                    id: 'ARMORED',
                    name: 'ARMORED',
                    color: 'slate',
                    icon: Shield,
                    iconBg: 'slate',
                    description: "Reduces damage by 50%. Spinning arc shield.",
                    visual: 'ARMORED'
                },
                {
                    id: 'RESIST_SLOW',
                    name: 'RESIST SLOW',
                    color: 'red',
                    icon: FastForward,
                    iconBg: 'red',
                    description: "Immune to freeze. Arrow shows direction.",
                    visual: 'RESIST_SLOW'
                },
                {
                    id: 'REGENERATION',
                    name: 'REGENERATION',
                    color: 'emerald',
                    icon: Activity,
                    iconBg: 'emerald',
                    description: "Heals 5% HP per second. Green sparkles.",
                    visual: 'REGENERATION'
                },
                {
                    id: 'SHIELDED',
                    name: 'SHIELDED',
                    color: 'cyan',
                    icon: Shield,
                    iconBg: 'cyan',
                    description: "Absorbs first 50 damage. Blue ring.",
                    visual: 'SHIELDED'
                }
            ]
        };

        const ENEMY_STATS = {
            [EnemyType.BASIC]: {
                radius: 10,
                color: '#ef4444',
                name: "Drone",
                hp: 20,
                speed: 1.25,
                reward: 10
            },
            [EnemyType.FAST]: {
                radius: 8,
                color: '#fbbf24',
                name: "Zerging",
                hp: 15,
                speed: 3.5,
                reward: 12
            },
            [EnemyType.TANK]: {
                radius: 18,
                color: '#10b981',
                name: "Hulk",
                hp: 60,
                speed: 0.7,
                reward: 25
            },
            [EnemyType.SPLITTER]: {
                radius: 16,
                color: '#8b5cf6',
                name: "Matryoshka",
                hp: 30,
                speed: 0.8,
                reward: 20
            },
            [EnemyType.SPLITTER_BIT]: {
                radius: 6,
                color: '#c084fc',
                name: "Bit",
                hp: 10,
                speed: 1.5,
                reward: 5
            },
            [EnemyType.MINIBOSS]: {
                radius: 25,
                color: '#f43f5e',
                name: "Praetorian",
                hp: 150,
                speed: 1.2,
                reward: 75
            },
            [EnemyType.BOSS]: {
                radius: 35,
                color: '#ec4899',
                name: "Titan",
                hp: 500,
                speed: 0.5,
                reward: 200
            },
            // Hard Mode enemies
            [EnemyType.SHOOTER]: {
                radius: 12,
                color: '#ff6b35',
                name: "Striker",
                hp: 25,
                speed: 0.8,
                reward: 30,
                attackRange: 250,
                attackCooldown: 2000
            },
            [EnemyType.DODGER]: {
                radius: 9,
                color: '#00d9ff',
                name: "Phantom",
                hp: 18,
                speed: 1.8,
                reward: 25,
                dodgeChance: 0.6,
                dodgeDistance: 40
            },
        };
        // Each effect has: name, color, onTick handler, speedMult
        const STATUS_EFFECTS = {
            BURN: {
                prop: 'burn',
                name: 'Burn',
                color: '#f97316',
                speedMult: 1,
                onTick: (e, r) => { e.hp -= 2; return r - 1; }
            },
            FREEZE: {
                prop: 'frozen',
                name: 'Freeze',
                color: '#22d3ee',
                speedMult: 0.3,
                getSpeedMult: (e) => e.traits?.includes?.(EnemyTrait.RESIST_SLOW) ? 0.8 : 0.3,
                onTick: (e, r) => r - 1
            },
            POISON: {
                prop: 'poison',
                name: 'Poison',
                color: '#84cc16',
                speedMult: 0.9,
                onTick: (e, r) => { e.hp -= 1.5; return r - 1; }
            },
            STUN: {
                prop: 'stunned',
                name: 'Stun',
                color: '#fcd34d',
                speedMult: 0,
                onTick: (e, r) => r - 1
            }
        };

        // processEffects: Loops through STATUS_EFFECTS config to apply logic
        const processEffects = (entity) => {
            let totalSpeedMult = 1;

            for (const key in STATUS_EFFECTS) {
                const effect = STATUS_EFFECTS[key];
                if (entity[effect.prop] > 0) {
                    // Apply tick logic (damage, duration reduction)
                    if (effect.onTick) { entity[effect.prop] = effect.onTick(entity, entity[effect.prop]); }
                    else { entity[effect.prop]--; }

                    // Apply speed multiplier
                    if (effect.getSpeedMult) { totalSpeedMult *= effect.getSpeedMult(entity); }
                    else { totalSpeedMult *= effect.speedMult; }
                }
            }
            return totalSpeedMult;
        };
        // Helper: Check if turret can fire based on cooldown
        const canFire = (turret, cooldown, gameTime) => {
            const ready = gameTime - turret.lastFired >= cooldown;
            return ready;
        };

        const findTargetHelper = (turret, rangeSq, tree, dims, targetingMode = TargetingMode.CLOSEST) => {
            const range = Math.sqrt(rangeSq);
            const candidates = tree.searchIndices({
                minX: turret.x - range, minY: turret.y - range,
                maxX: turret.x + range, maxY: turret.y + range
            }, enemySystem);

            if (candidates.length === 0) return null;

            const corePosX = dims.w / 2;
            const corePosY = dims.h / 2;

            let bestIndex = -1;
            let bestValue = null;

            for (const idx of candidates) {
                if (enemySystem.hp[idx] <= 0) continue;

                const ex = enemySystem.x[idx];
                const ey = enemySystem.y[idx];
                const dSq = (turret.x - ex) ** 2 + (turret.y - ey) ** 2;

                if (dSq > rangeSq) continue;

                let value;
                switch (targetingMode) {
                    case TargetingMode.CLOSEST:
                        value = -dSq;
                        break;
                    case TargetingMode.FIRST:
                        value = -((ex - corePosX) ** 2 + (ey - corePosY) ** 2);
                        break;
                    case TargetingMode.LAST:
                        value = (ex - corePosX) ** 2 + (ey - corePosY) ** 2;
                        break;
                    case TargetingMode.STRONG:
                        value = enemySystem.hp[idx];
                        break;
                    case TargetingMode.WEAK:
                        value = -enemySystem.hp[idx];
                        break;
                    default:
                        value = -dSq;
                }
                if (bestValue === null || value > bestValue) {
                    bestValue = value;
                    bestIndex = idx;
                }
            }

            if (bestIndex === -1) return null;

            return {
                index: bestIndex,
                distSq: (turret.x - enemySystem.x[bestIndex]) ** 2 + (turret.y - enemySystem.y[bestIndex]) ** 2
            };
        };


        // Turret Behavior Definitions (Strategy Pattern)
        // Each behavior has: { onUpdate: (turret, ctx) => void }
        // ctx contains: { state, stats, tree, dims, spawnProjectile, spawnParticles, spawnFloatingText, etc. }
        // Behavior Helpers
        const createSingleTargetBehavior = (attackFn) => ({
            onUpdate: (turret, ctx) => {
                const { state, stats, tree, dims } = ctx;
                if (!canFire(turret, stats.effectiveCooldown, state.gameTime)) return;
                const result = findTargetHelper(turret, stats.effectiveRangeSq, tree, dims, turret.targetingMode);
                if (result) {
                    attackFn(turret, ctx, result.index, result.distSq);
                    turret.lastFired = state.gameTime;
                }
            }
        });

        const createAreaBehavior = (effectFn, onHitAnyFn) => ({
            onUpdate: (turret, ctx) => {
                const { state, stats, tree } = ctx;
                if (!canFire(turret, stats.effectiveCooldown, state.gameTime)) return;
                const range = Math.sqrt(stats.effectiveRangeSq);
                const candidates = tree.searchIndices({ minX: turret.x - range, minY: turret.y - range, maxX: turret.x + range, maxY: turret.y + range }, enemySystem);
                let hitAny = false;
                for (const idx of candidates) {
                    if (enemySystem.hp[idx] <= 0) continue;
                    const dSq = (turret.x - enemySystem.x[idx]) ** 2 + (turret.y - enemySystem.y[idx]) ** 2;
                    if (dSq <= stats.effectiveRangeSq) {
                        effectFn(turret, ctx, idx, dSq);
                        hitAny = true;
                    }
                }
                if (hitAny && onHitAnyFn) onHitAnyFn(turret, ctx);
                turret.lastFired = state.gameTime;
            }
        });

        // @turret-behaviors — Runtime attack/effect logic for each turret type
        const TurretBehaviors = {
            [TurretType.PRISM]: { onUpdate: () => { } },

            [TurretType.FLAMETHROWER]: createSingleTargetBehavior((turret, ctx, idx, distSq) => {
                const { stats, spawnParticles, spawnFloatingText } = ctx;
                const tx = enemySystem.x[idx], ty = enemySystem.y[idx];
                const angle = Math.atan2(ty - turret.y, tx - turret.x);

                // Cone of fire particles instead of a projectile
                // Colors range from yellow to dark orange/red
                const colors = ['#fde047', '#f97316', '#ef4444', '#b91c1c'];
                const color = colors[Math.floor(Math.random() * colors.length)];

                if (ctx.spawnDirectional) {
                    // count, angle, spread, speedMult, sizeMult
                    ctx.spawnDirectional(turret.x, turret.y, color, 5, angle, 0.6, 1, 1);
                }

                if (distSq < stats.effectiveRangeSq * 0.8) {
                    enemySystem.hp[idx] -= stats.effectiveDamage;
                    if (enemySystem.hp[idx] <= 0) turret.killCount++;

                    const burnTime = 300;
                    enemySystem.burn[idx] = Math.max(enemySystem.burn[idx] || 0, burnTime);
                    // Combos
                    if (enemySystem.poison[idx] > 0) {
                        spawnParticles(tx, ty, '#84cc16', 15, 1.5); spawnFloatingText(tx, ty, "GAS CLOUD!", '#84cc16', 18);
                        const areaIndices = ctx.tree.searchIndices({ minX: tx - 80, minY: ty - 80, maxX: tx + 80, maxY: ty + 80 }, enemySystem);
                        for (const aid of areaIndices) { if ((enemySystem.x[aid] - tx) ** 2 + (enemySystem.y[aid] - ty) ** 2 < 6400) enemySystem.poison[aid] = 300; }
                    }
                    if (enemySystem.frozen[idx] > 0) { spawnParticles(tx, ty, '#ef4444', 10); spawnFloatingText(tx, ty, "MELT!", '#ef4444', 16); enemySystem.hp[idx] -= 20; enemySystem.frozen[idx] = 0; }
                }
            }),

            [TurretType.FREEZE]: createAreaBehavior((turret, ctx, idx) => {
                const tStats = ctx.TURRET_STATS?.[turret.type] || {};
                const slowDuration = tStats.slowMult ? Math.floor(30 / (1 - tStats.slowMult + 0.1)) : 30;
                enemySystem.hp[idx] -= ctx.stats.effectiveDamage * 0.2;
                enemySystem.frozen[idx] = slowDuration;
                if (enemySystem.hp[idx] <= 0) turret.killCount++;
            }),

            // Evolved freeze turrets use same behavior via lookup
            [EvolutionType.FREEZE_PERMA]: createAreaBehavior((turret, ctx, idx) => {
                enemySystem.hp[idx] -= ctx.stats.effectiveDamage * 0.3;
                enemySystem.frozen[idx] = 60; // Stronger freeze
                if (enemySystem.hp[idx] <= 0) turret.killCount++;
            }),
            [EvolutionType.FREEZE_BLIZZARD]: createAreaBehavior((turret, ctx, idx) => {
                enemySystem.hp[idx] -= ctx.stats.effectiveDamage * 0.15;
                enemySystem.frozen[idx] = 25;
                if (enemySystem.hp[idx] <= 0) turret.killCount++;
            }),

            [TurretType.SHOCK]: createSingleTargetBehavior((turret, ctx, idx) => {
                const { stats, spawnLightning, spawnFloatingText } = ctx;
                const chainLimit = 4;
                let currentIdx = idx, lastX = turret.x, lastY = turret.y, chains = 0;
                const hitIndices = new Set([currentIdx]);

                while (chains < chainLimit && currentIdx !== -1) {
                    const ex = enemySystem.x[currentIdx], ey = enemySystem.y[currentIdx];
                    spawnLightning(lastX, lastY, ex, ey, '#e879f9');
                    enemySystem.hp[currentIdx] -= stats.effectiveDamage;
                    if (enemySystem.hp[currentIdx] <= 0) turret.killCount++;
                    if (enemySystem.poison[currentIdx] > 0 && Math.random() < 0.3) { enemySystem.stunned[currentIdx] = 60; spawnFloatingText(ex, ey, "PARALYZED", '#e879f9', 14); }

                    lastX = ex; lastY = ey; chains++;

                    const nextCandidates = ctx.tree.searchIndices({ minX: ex - 200, minY: ey - 200, maxX: ex + 200, maxY: ey + 200 }, enemySystem);
                    let nextBest = -1, minDSq = Infinity;
                    for (const nIdx of nextCandidates) {
                        if (enemySystem.hp[nIdx] > 0 && !hitIndices.has(nIdx)) {
                            const dSq = (ex - enemySystem.x[nIdx]) ** 2 + (ey - enemySystem.y[nIdx]) ** 2;
                            if (dSq < 40000 && dSq < minDSq) { minDSq = dSq; nextBest = nIdx; }
                        }
                    }
                    if (nextBest !== -1) { hitIndices.add(nextBest); currentIdx = nextBest; } else { currentIdx = -1; }
                }
            }),

            [EvolutionType.SHOCK_OVERLOAD]: createSingleTargetBehavior((turret, ctx, idx) => {
                const { stats, spawnLightning, spawnFloatingText } = ctx;
                const chainLimit = 4;
                let currentIdx = idx, lastX = turret.x, lastY = turret.y, chains = 0;
                const hitIndices = new Set([currentIdx]);

                while (chains < chainLimit && currentIdx !== -1) {
                    const ex = enemySystem.x[currentIdx], ey = enemySystem.y[currentIdx];
                    spawnLightning(lastX, lastY, ex, ey, '#fbbf24', 3); // Thicker gold lightning
                    enemySystem.hp[currentIdx] -= stats.effectiveDamage;
                    if (enemySystem.hp[currentIdx] <= 0) turret.killCount++;

                    // Stronger base stun chance, guaranteed 120-tick stun if poisoned
                    if (Math.random() < 0.3 || enemySystem.poison[currentIdx] > 0) {
                        enemySystem.stunned[currentIdx] = 120;
                        spawnFloatingText(ex, ey, "OVERLOAD!", '#fbbf24', 16);
                    }

                    lastX = ex; lastY = ey; chains++;

                    const nextCandidates = ctx.tree.searchIndices({ minX: ex - 200, minY: ey - 200, maxX: ex + 200, maxY: ey + 200 }, enemySystem);
                    let nextBest = -1, minDSq = Infinity;
                    for (const nIdx of nextCandidates) {
                        if (enemySystem.hp[nIdx] > 0 && !hitIndices.has(nIdx)) {
                            const dSq = (ex - enemySystem.x[nIdx]) ** 2 + (ey - enemySystem.y[nIdx]) ** 2;
                            if (dSq < 40000 && dSq < minDSq) { minDSq = dSq; nextBest = nIdx; }
                        }
                    }
                    if (nextBest !== -1) { hitIndices.add(nextBest); currentIdx = nextBest; } else { currentIdx = -1; }
                }
            }),

            [EvolutionType.SHOCK_STORM]: createSingleTargetBehavior((turret, ctx, idx) => {
                const { stats, spawnLightning, spawnFloatingText } = ctx;
                const chainLimit = 5;
                let currentIdx = idx, lastX = turret.x, lastY = turret.y, chains = 0;
                const hitIndices = new Set([currentIdx]);

                // Normal chaining attack (Indigo color)
                while (chains < chainLimit && currentIdx !== -1) {
                    const ex = enemySystem.x[currentIdx], ey = enemySystem.y[currentIdx];
                    spawnLightning(lastX, lastY, ex, ey, '#818cf8', 2);
                    enemySystem.hp[currentIdx] -= stats.effectiveDamage;
                    if (enemySystem.hp[currentIdx] <= 0) turret.killCount++;
                    if (Math.random() < 0.2) enemySystem.stunned[currentIdx] = 40; // Small stun chance

                    lastX = ex; lastY = ey; chains++;

                    const nextCandidates = ctx.tree.searchIndices({ minX: ex - 200, minY: ey - 200, maxX: ex + 200, maxY: ey + 200 }, enemySystem);
                    let nextBest = -1, minDSq = Infinity;
                    for (const nIdx of nextCandidates) {
                        if (enemySystem.hp[nIdx] > 0 && !hitIndices.has(nIdx)) {
                            const dSq = (ex - enemySystem.x[nIdx]) ** 2 + (ey - enemySystem.y[nIdx]) ** 2;
                            if (dSq < 40000 && dSq < minDSq) { minDSq = dSq; nextBest = nIdx; }
                        }
                    }
                    if (nextBest !== -1) { hitIndices.add(nextBest); currentIdx = nextBest; } else { currentIdx = -1; }
                }

                // Thunder Storm effect: Strike ALL stunned enemies on the map
                const stormDamage = stats.effectiveDamage * 0.5;
                let strikes = 0;
                for (let i = 0; i < enemySystem.count; i++) {
                    if (enemySystem.hp[i] > 0 && enemySystem.stunned[i] > 0 && !hitIndices.has(i)) {
                        const ex = enemySystem.x[i], ey = enemySystem.y[i];
                        // Strike from the sky (turret.y - 300) to the enemy
                        spawnLightning(ex, ey - 300, ex, ey, '#c7d2fe', 4);
                        enemySystem.hp[i] -= stormDamage;
                        if (enemySystem.hp[i] <= 0) turret.killCount++;
                        spawnFloatingText(ex, ey, "STORM", '#c7d2fe', 16);
                        strikes++;
                        if (strikes > 10) break; // Cap at 10 to not fry performance
                    }
                }
            }),

            [TurretType.ACID]: createSingleTargetBehavior((turret, ctx, idx) => {
                const { stats, spawnProjectile } = ctx;
                const tId = enemySystem.ids[idx];
                // Acid visually defined in handleProjectileHit with burst
                spawnProjectile(turret, { x: enemySystem.x[idx], y: enemySystem.y[idx], vx: enemySystem.vx[idx], vy: enemySystem.vy[idx], id: tId }, {
                    damage: stats.effectiveDamage, speed: 8, color: '#84cc16', shape: 'GLOB', radius: 6,
                    statusEffect: { type: 'ACID', duration: 300 }, turretId: turret.id, targetId: tId
                });
            }),

            // AOE creates an expanding ring blast
            [TurretType.AOE]: createAreaBehavior((turret, ctx, idx) => {
                const { stats } = ctx;
                enemySystem.hp[idx] -= stats.effectiveDamage;
                if (Math.random() < 0.2) enemySystem.stunned[idx] = 30;
            }, (turret, ctx) => {
                expandingRingSystem.add(turret.x, turret.y, Math.sqrt(ctx.stats.effectiveRangeSq), turret.color || '#f59e0b', 20);
                // Also some central debris/dust
                ctx.spawnParticles(turret.x, turret.y, turret.color || '#f59e0b', 8, 2.0);
            }),

            [TurretType.GRAVITY_WELL]: {
                onUpdate: (turret, ctx) => { // Kept custom due to "always active" nature (no cooldown check)
                    const { stats, tree } = ctx;
                    const range = Math.sqrt(stats.effectiveRangeSq);
                    const candidates = tree.searchIndices({ minX: turret.x - range, minY: turret.y - range, maxX: turret.x + range, maxY: turret.y + range }, enemySystem);
                    for (const idx of candidates) {
                        if (enemySystem.hp[idx] <= 0) continue;
                        const ex = enemySystem.x[idx], ey = enemySystem.y[idx];
                        const dSq = (turret.x - ex) ** 2 + (turret.y - ey) ** 2;
                        if (dSq <= stats.effectiveRangeSq) {
                            const dist = Math.sqrt(dSq);
                            if (dist > 5) {
                                const angle = Math.atan2(turret.y - ey, turret.x - ex);
                                const pullStrength = 0.8;
                                enemySystem.x[idx] += Math.cos(angle) * pullStrength;
                                enemySystem.y[idx] += Math.sin(angle) * pullStrength;
                            }
                            enemySystem.hp[idx] -= 0.3;
                        }
                    }
                }
            },

            [TurretType.RAILGUN]: { // Kept custom due to charge logic
                onUpdate: (turret, ctx) => {
                    const { state, stats, tree, spawnRailgunBeam, spawnFloatingText, spawnParticles, FIXED_STEP } = ctx;
                    if (!turret.charge) turret.charge = 0;
                    if (turret.charge < 100) { turret.charge += (100 / stats.effectiveCooldown) * FIXED_STEP; }
                    else {
                        const range = Math.sqrt(stats.effectiveRangeSq);
                        let best = -1, maxHp = -1;
                        const candidates = tree.searchIndices({ minX: turret.x - range, minY: turret.y - range, maxX: turret.x + range, maxY: turret.y + range }, enemySystem);
                        for (const idx of candidates) { if (enemySystem.hp[idx] > maxHp) { maxHp = enemySystem.hp[idx]; best = idx; } }

                        if (best !== -1) {
                            const tx = enemySystem.x[best], ty = enemySystem.y[best];
                            const beamWidth = 8;
                            spawnRailgunBeam(turret.x, turret.y, tx, ty, '#22d3ee', beamWidth);
                            enemySystem.hp[best] -= stats.effectiveDamage;
                            spawnFloatingText(tx, ty, Math.floor(stats.effectiveDamage).toString(), '#06b6d4', 24);
                            spawnParticles(tx, ty, '#22d3ee', 15, 2);
                            turret.charge = 0;
                            if (enemySystem.hp[best] <= 0) turret.killCount++;
                        }
                    }
                }
            },

            DEFAULT: createSingleTargetBehavior((turret, ctx, idx) => {
                const { state, stats, spawnProjectile, spawnParticles, UpgradeType, TURRET_STATS } = ctx;
                const target = { x: enemySystem.x[idx], y: enemySystem.y[idx], vx: enemySystem.vx[idx], vy: enemySystem.vy[idx], id: enemySystem.ids[idx] };
                const tStats = TURRET_STATS[turret.type] || {};

                // Base shot count + multishot upgrade
                let baseShots = tStats.projectileCount || 1;
                const totalShots = baseShots + (state.upgrades[UpgradeType.MULTISHOT] || 0);

                const isCrit = Math.random() < ((state.upgrades[UpgradeType.CRIT_CHANCE] || 0) * 0.05);
                const critMult = isCrit ? (2 + (state.upgrades[UpgradeType.CRIT_DAMAGE] || 0) * 0.5) : 1;

                // Status effects based on turret type
                let statusEffect = null;
                if (turret.type === TurretType.ACID) statusEffect = { type: 'ACID', duration: 180 };
                else if (turret.type === TurretType.SHOCK) statusEffect = { type: 'SHOCK', duration: 60 };
                else if (turret.type === EvolutionType.SHOCK_OVERLOAD) statusEffect = { type: 'SHOCK', duration: tStats.stunDuration || 120 };
                else if (turret.type === EvolutionType.MISSILE_NAPALM) statusEffect = { type: 'FIRE', duration: 180 };

                // Calculate spread for scatter-type turrets
                const isMissileType = turret.type === TurretType.MISSILE || turret.type === EvolutionType.MISSILE_NAPALM || turret.type === EvolutionType.MISSILE_SWARM;
                const isScatter = turret.type === EvolutionType.BLASTER_SCATTER || baseShots > 1;
                const spreadAngle = isScatter ? 0.25 : 0.1;

                for (let i = 0; i < totalShots; i++) {
                    const spread = (i - (totalShots - 1) / 2) * spreadAngle;
                    spawnProjectile(turret, target, {
                        damage: stats.effectiveDamage * critMult / (isScatter ? baseShots * 0.7 : 1),
                        speed: 6 + ((tStats.stats?.speed || 3) * 1.5),
                        color: tStats.color || '#ffffff',
                        shape: isMissileType ? 'ROCKET' : (turret.type === TurretType.BLASTER || turret.type === TurretType.RAPID || turret.type === TurretType.SNIPER || turret.type === EvolutionType.BLASTER_PLASMA || turret.type === EvolutionType.BLASTER_SCATTER) ? 'LINE' : 'CIRCLE',
                        isMissile: isMissileType, isCrit, turretId: turret.id, statusEffect,
                        pierce: tStats.pierce || false
                    }, spread);
                }
                if (turret.type === TurretType.AOE) spawnParticles(turret.x, turret.y, '#f59e0b', 10);

                // Thunder Storm: damage all stunned enemies in range
                if (turret.type === EvolutionType.SHOCK_STORM) {
                    const range = stats.effectiveRangeSq;
                    for (let e = 0; e < enemySystem.count; e++) {
                        if (enemySystem.stunned[e] > 0) {
                            const dx = enemySystem.x[e] - turret.x, dy = enemySystem.y[e] - turret.y;
                            if (dx * dx + dy * dy < range) {
                                enemySystem.hp[e] -= stats.effectiveDamage * (tStats.aoeDamageToStunned || 0.5);
                                spawnParticles(enemySystem.x[e], enemySystem.y[e], tStats.color, 5);
                            }
                        }
                    }
                }
            })
        };
        // Turrets gain tiers based on survival time, affecting their stats

        // Helper to create upgrade definition objects compactly
        const createUpgradeDef = (name, description, baseCost, costMultiplier, effectFormatStr, extra = {}) => ({
            name, description, baseCost, costMultiplier,
            effectDescription: (lvl) => effectFormatStr.replace('$$', lvl * (extra.scale || 1) + (extra.base || 0)),
            ...extra
        });

        const UPGRADE_STATS = {
            [UpgradeType.GLOBAL_DAMAGE]:
                createUpgradeDef("Plasma Potency",
                    "Increases damage of all turrets.",
                    100,
                    1.6,
                    "Damage: +$$%",
                    { scale: 10 }),
            [UpgradeType.GLOBAL_RATE]:
                createUpgradeDef("Rapid Cylinders",
                    "Increases fire rate of all turrets.",
                    150,
                    1.7,
                    "Fire Rate: +$$%",
                    { scale: 5 }),
            [UpgradeType.GLOBAL_RANGE]:
                createUpgradeDef("Lidar Sensors",
                    "Increases range of all turrets.",
                    75,
                    1.5,
                    "Range: +$$%",
                    { scale: 10 }),
            [UpgradeType.MULTISHOT]:
                createUpgradeDef("Split Chamber",
                    "Adds additional projectiles to every shot.",
                    2000,
                    3.0,
                    "Multishot: +$$ Proj"),
            [UpgradeType.CRIT_CHANCE]:
                createUpgradeDef("Targeting AI",
                    "Chance to deal critical damage.",
                    200,
                    1.6,
                    "Crit Chance: $$%",
                    { scale: 5 }),
            [UpgradeType.CRIT_DAMAGE]:
                createUpgradeDef("Core Overcharge",
                    "Increases critical hit damage multiplier.",
                    200,
                    1.6,
                    "Crit Dmg: $$%",
                    { base: 150, scale: 25 }),
            [UpgradeType.MAX_HEALTH]:
                createUpgradeDef("Reinforced Hull",
                    "Increases maximum Core Integrity.",
                    100,
                    1.4,
                    "Max HP: +$$",
                    { scale: 25 }),
            [UpgradeType.DAMAGE_REDUCTION]: {
                name: "Energy Shields",
                description: "Reduces incoming damage from enemies.",
                baseCost: 300,
                costMultiplier: 2.5,
                effectDescription: (lvl) => `Armor: ${Math.min(50, lvl * 5)}%`
            }
        };

        const META_UPGRADE_STATS = {
            [MetaUpgradeType.STARTING_CASH]:
                createUpgradeDef("Venture Capital",
                    "Start each run with more credits.",
                    10,
                    1.5,
                    "Start +$$$",
                    { maxLevel: 20, scale: 50 }),
            [MetaUpgradeType.CORE_SHIELDING]:
                createUpgradeDef("Adamantium Core",
                    "Permanent boost to base health.",
                    20,
                    1.4,
                    "Base HP +$$",
                    { maxLevel: 20, scale: 25 }),
            [MetaUpgradeType.SCRAP_RECYCLING]:
                createUpgradeDef("Scrap Logistics",
                    "Enemies drop more credits.",
                    50,
                    2.0,
                    "Rewards +$$%",
                    { maxLevel: 10, scale: 10 }),
            [MetaUpgradeType.TURRET_MASTERY]:
                createUpgradeDef("Weapon Mastery",
                    "Permanent damage multiplier for all turrets.",
                    100,
                    2.5,
                    "Dmg +$$%",
                    { maxLevel: 10, scale: 5 }),
            [MetaUpgradeType.DISCOUNT_ENGINEERING]:
                createUpgradeDef("Efficient Builds",
                    "Reduces the cost of all turrets.",
                    75,
                    2.0,
                    "Cost -$$%",
                    { maxLevel: 10, scale: 2 })
        };
        /** Pre-generates all static textures at startup to prevent pop-in */
        const preloadAssets = async (app) => {
            const textures = {};

            // Generate turret textures for all types and colors
            Object.entries(TURRET_STATS).forEach(([type, stats]) => {
                const g = new PIXI.Graphics();
                const color = parseInt(stats.color.replace('#', ''), 16);
                const shapeData = TURRET_SHAPES[type] || TURRET_SHAPES.DEFAULT;
                if (shapeData.type === 'custom') {
                    if (type === 'RAILGUN') { g.rect(-14, -6, 28, 12).fill(color); g.rect(-10, -2, 20, 4).fill(0x000000); }
                    else if (type === 'ACID') { g.circle(0, 0, 10);[[-5, -15], [5, -15], [0, 0]].forEach((p, i) => i === 0 ? g.moveTo(p[0], p[1]) : g.lineTo(p[0], p[1])); g.closePath().fill(color); }
                } else if (shapeData.type === 'rect') { g.rect(...shapeData.args).fill(color); }
                else if (shapeData.type === 'circle') { g.circle(...shapeData.args).fill(color); }
                else if (shapeData.type === 'poly') { shapeData.points.forEach((p, i) => i === 0 ? g.moveTo(p[0], p[1]) : g.lineTo(p[0], p[1])); g.closePath().fill(color); }
                textures[`turret_${type}`] = app.renderer.generateTexture(g);
                g.destroy();
            });

            // Generate common projectile textures
            ['#3b82f6', '#f97316', '#8b5cf6', '#22d3ee', '#84cc16'].forEach(colorHex => {
                const color = parseInt(colorHex.replace('#', ''), 16);
                [3, 4, 5, 6].forEach(radius => {
                    const g = new PIXI.Graphics();
                    g.circle(0, 0, radius).fill(color);
                    textures[`proj_${colorHex}_${radius}`] = app.renderer.generateTexture(g);
                    g.destroy();
                });
            });

            // Generate pip texture
            const pipG = new PIXI.Graphics();
            pipG.circle(0, 0, 2).fill(0xffffff);
            textures.pip = app.renderer.generateTexture(pipG);
            pipG.destroy();

            // Generate core textures (normal and damaged)
            ['#0ea5e9', '#ef4444'].forEach(colorHex => {
                const color = parseInt(colorHex.replace('#', ''), 16);
                const g = new PIXI.Graphics();
                g.circle(0, 0, 30).fill(color);
                g.circle(0, 0, 30).stroke({ width: 3, color: 0xffffff });
                textures[`core_${colorHex}`] = app.renderer.generateTexture(g);
                g.destroy();
            });

            // Generate particle texture
            const particleG = new PIXI.Graphics();
            particleG.circle(8, 8, 8).fill(0xffffff);
            textures.particle = app.renderer.generateTexture(particleG);
            particleG.destroy();

            return textures;
        };


        // ==================== ENTITY SYSTEMS (RUNTIME DATA) ====================
        //Factory for creating Structure of Arrays (SoA) systems.
        //Reduces boilerplate for defining TypedArrays and flyweight accessors.
        class SoABuilder {
            constructor(capacity) {
                this.capacity = capacity;
                this.schema = [];
            }

            addFloat(name, def = 0) {
                this.schema.push({
                    name,
                    type: Float32Array,
                    def
                }); return this;
            }
            addInt32(name, def = 0) {
                this.schema.push({
                    name,
                    type: Int32Array,
                    def
                }); return this;
            }
            addUint32(name, def = 0) {
                this.schema.push({
                    name,
                    type: Uint32Array,
                    def
                }); return this;
            }
            addUint16(name, def = 0) {
                this.schema.push({
                    name,
                    type: Uint16Array,
                    def
                }); return this;
            }
            addUint8(name, def = 0) {
                this.schema.push({
                    name,
                    type: Uint8Array,
                    def
                }); return this;
            }
            addArray(name, def = null) {
                this.schema.push({
                    name,
                    type: Array,
                    def
                }); return this;
            }

            build() {
                const capacity = this.capacity;
                const schema = this.schema;

                return class GeneratedSystem {
                    constructor() {
                        this.capacity = capacity;
                        this.count = 0;

                        // Initialize Arrays
                        schema.forEach(field => {
                            this[field.name] = new field.type(capacity);
                        });

                        // Create Flyweight (View)
                        this.flyweight = { sys: this, index: 0 };
                        schema.forEach(field => {
                            Object.defineProperty(this.flyweight, field.name, {
                                get() { return this.sys[field.name][this.index]; },
                                set(v) { this.sys[field.name][this.index] = v; },
                                enumerable: true,
                                configurable: true
                            });
                        });
                    }

                    spawn(data = {}) {
                        if (this.count >= this.capacity) return -1;
                        const i = this.count++;

                        schema.forEach(field => {
                            const val = data[field.name];
                            this[field.name][i] = val !== undefined ? val : field.def;
                        });
                        return i;
                    }

                    remove(index) {
                        if (index < 0 || index >= this.count) return;
                        const last = this.count - 1;
                        if (index !== last) schema.forEach(field => { this[field.name][index] = this[field.name][last]; });
                        this.count--;
                    }

                    get(i) {
                        this.flyweight.index = i;
                        return this.flyweight;
                    }

                    reset() {
                        this.count = 0;
                    }

                    toArray() { // Helper for debugging/snapshots
                        const arr = [];
                        for (let i = 0; i < this.count; i++) {
                            this.flyweight.index = i;
                            const obj = {};
                            schema.forEach(f => obj[f.name] = this.flyweight[f.name]);
                            arr.push(obj);
                        }
                        return arr;
                    }
                };
            }
        }
        // Generated Base Class
        const ParticleBase = new SoABuilder(GAME_CONSTANTS.PARTICLE_SYSTEM_CAPACITY)
            .addFloat('x').addFloat('y').addFloat('vx').addFloat('vy')
            .addFloat('life').addFloat('size').addUint32('color')
            .build();

        class ParticleSystem extends ParticleBase {
            constructor() { super(); }

            spawn(x, y, colorHex, count, speedMult = 1, sizeMult = 1) {
                const color = typeof colorHex === 'string' ? parseInt(colorHex.replace('#', ''), 16) : colorHex;

                for (let i = 0; i < count; i++) {
                    if (this.count >= this.capacity) return;

                    const angle = Math.random() * Math.PI * 2;
                    const speed = (Math.random() * 3 + 1) * speedMult;

                    // Use base spawn or direct assignment?
                    // Direct assignment for bulk efficient spawn without object creation
                    const idx = this.count++;

                    this.x[idx] = x;
                    this.y[idx] = y;
                    this.vx[idx] = Math.cos(angle) * speed;
                    this.vy[idx] = Math.sin(angle) * speed;
                    this.life[idx] = 20 + Math.random() * 10;
                    this.color[idx] = color;
                    this.size[idx] = (Math.random() * 2 + 1) * sizeMult;
                }
            }

            spawnSingle(x, y, vx, vy, life, colorHex, size) {
                if (this.count >= this.capacity) return;
                const color = typeof colorHex === 'string' ? parseInt(colorHex.replace('#', ''), 16) : colorHex;
                const idx = this.count++;
                this.x[idx] = x;
                this.y[idx] = y;
                this.vx[idx] = vx;
                this.vy[idx] = vy;
                this.life[idx] = life;
                this.color[idx] = color;
                this.size[idx] = size;
            }

            spawnDirectional(x, y, colorHex, count, angle, spread, speedMult = 1, sizeMult = 1) {
                const color = typeof colorHex === 'string' ? parseInt(colorHex.replace('#', ''), 16) : colorHex;
                for (let i = 0; i < count; i++) {
                    if (this.count >= this.capacity) return;
                    const particleAngle = angle + (Math.random() - 0.5) * spread;
                    const speed = (Math.random() * 4 + 4) * speedMult;
                    const idx = this.count++;
                    this.x[idx] = x + Math.cos(particleAngle) * 10;
                    this.y[idx] = y + Math.sin(particleAngle) * 10;
                    this.vx[idx] = Math.cos(particleAngle) * speed;
                    this.vy[idx] = Math.sin(particleAngle) * speed;
                    this.life[idx] = 15 + Math.random() * 15;
                    this.color[idx] = color;
                    this.size[idx] = (Math.random() * 8 + 8) * sizeMult;
                }
            }

            update() {
                for (let i = 0; i < this.count; i++) {
                    // Update physics
                    this.x[i] += this.vx[i];
                    this.y[i] += this.vy[i];
                    this.vx[i] *= 0.95; // Drag
                    this.vy[i] *= 0.95;
                    this.life[i]--;

                    // Removal check
                    if (this.life[i] <= 0) {
                        this.remove(i);
                        i--; // Re-process this index
                    }
                }
            }
        }

        const particleSystem = new ParticleSystem();
        const lightningSystem = {
            items: [],
            add(x1, y1, x2, y2, color, width) {
                this.items.push({ x1, y1, x2, y2, color, width, life: 15, maxLife: 15 });
            },
            update() {
                for (let i = this.items.length - 1; i >= 0; i--) {
                    if (--this.items[i].life <= 0) this.items.splice(i, 1);
                }
            }
        };

        const expandingRingSystem = {
            items: [],
            add(x, y, maxRadius, color, maxLife = 20) {
                this.items.push({ x, y, radius: 0, maxRadius, color, life: maxLife, maxLife });
            },
            update() {
                for (let i = this.items.length - 1; i >= 0; i--) {
                    const r = this.items[i];
                    r.radius += (r.maxRadius - r.radius) * 0.2;
                    if (--r.life <= 0) this.items.splice(i, 1);
                }
            }
        };

        /**
         * Projectile system � manages active projectiles as plain objects.
         * Handles movement, homing, collision detection (via SpatialGrid), and lifecycle.
         */
        const projectileSystem = {
            items: [],
            get count() { return this.items.length; },

            spawn(data) {
                this.items.push({
                    x: data.x || 0, y: data.y || 0,
                    vx: data.vx || 0, vy: data.vy || 0,
                    angle: data.angle || 0, speed: data.speed || 0,
                    life: data.life ?? 60,
                    damage: data.damage || 0,
                    radius: data.radius ?? 3,
                    targetX: data.targetX || 0, targetY: data.targetY || 0,
                    color: typeof data.color === 'string' ? parseInt(data.color.replace('#', ''), 16) : (data.color ?? 0xFFFFFF),
                    isMissile: !!data.isMissile,
                    isCrit: !!data.isCrit,
                    cosmetic: !!data.cosmetic,
                    shape: data.shape || 'CIRCLE',
                    targetId: data.targetId || null,
                    turretId: data.turretId || null,
                    statusEffect: data.statusEffect || null
                });
            },

            get(i) {
                const p = this.items[i];
                // Render expects hex string color
                return { ...p, color: '#' + p.color.toString(16).padStart(6, '0') };
            },

            remove(i) { this.items.splice(i, 1); },
            reset() { this.items.length = 0; },

            update(enemySystem, tree, onHit) {
                const W = 1920, H = 1080;

                for (let i = 0; i < this.items.length; i++) {
                    const p = this.items[i];
                    let remove = false;

                    // Homing Logic
                    if (p.targetId && !p.cosmetic) {
                        let targetIndex = -1;
                        for (let k = 0; k < enemySystem.count; k++) {
                            if (enemySystem.ids[k] === p.targetId) { targetIndex = k; break; }
                        }

                        if (targetIndex !== -1 && enemySystem.hp[targetIndex] > 0) {
                            const tx = enemySystem.x[targetIndex];
                            const ty = enemySystem.y[targetIndex];
                            const angleToTarget = Math.atan2(ty - p.y, tx - p.x);
                            let angleDiff = angleToTarget - p.angle;
                            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                            const maxTurnRate = GAME_CONSTANTS.HOMING_TURN_RATE;
                            const turnAmount = Math.max(-maxTurnRate, Math.min(maxTurnRate, angleDiff));

                            p.angle += turnAmount;
                            p.vx = Math.cos(p.angle) * p.speed;
                            p.vy = Math.sin(p.angle) * p.speed;
                        }
                    }

                    // Physics
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;

                    // Collision detection via Spatial Grid
                    if (!p.cosmetic) {
                        const searchRad = p.radius + 40;
                        const nearby = tree.searchIndices({
                            minX: p.x - searchRad, minY: p.y - searchRad,
                            maxX: p.x + searchRad, maxY: p.y + searchRad
                        }, enemySystem);

                        for (const idx of nearby) {
                            if (enemySystem.hp[idx] <= 0) continue;

                            const ex = enemySystem.x[idx];
                            const ey = enemySystem.y[idx];
                            const er = enemySystem.radius[idx];
                            const dx = p.x - ex;
                            const dy = p.y - ey;
                            const distSq = dx * dx + dy * dy;

                            if (distSq < (p.radius + er) ** 2) {
                                const enemyObj = enemySystem.get(idx);
                                onHit({
                                    x: p.x, y: p.y,
                                    damage: p.damage,
                                    turretId: p.turretId,
                                    statusEffect: p.statusEffect,
                                    isCrit: p.isCrit,
                                    color: '#' + p.color.toString(16).padStart(6, '0')
                                }, enemyObj, idx);
                                remove = true;
                                break;
                            }
                        }
                    }

                    // Bounds / Life check
                    if (p.life <= 0 || p.x < -50 || p.x > W + 50 || p.y < -50 || p.y > H + 50) { remove = true; }
                    if (remove) { this.items.splice(i, 1); i--; }
                }
            }
        };
        const shallowStr = (a, b) => JSON.stringify(a) === JSON.stringify(b);
        // ==================== STATE MANAGEMENT (ZUSTAND STORE) ====================
        const STORAGE_KEY = 'neon_core_meta_v1';
        const SAVE_SLOT_KEY = 'neon_core_save_game_v1';
        // State shape overview:
        //   UI:       gameState, gameSpeed, showUpgrades, showTechLab, showCodex, codexTab, saveMessage
        //   Player:   money, health, score, coreLevel, gameTime, difficultyRating
        //   Meta:     metaState { techPoints, prestigeLevel, prestigePoints, unlockedVariants, upgrades }
        //   Gameplay: upgrades, selectedTurretType/Id, selectedCoreWeapon,
        //             activeModules, moduleCooldowns, mutations, turretVersion, isHardMode
        //   Actions:  setSelectedTurretType, setSelectedTurretId, setShowCodex, setCodexTab, etc.
        const useGameStore = window.createZustand((set, get) => ({
            // UI State
            gameState: GameStatus.IDLE,
            gameSpeed: 1,
            showUpgrades: false,
            showTechLab: false,
            showCodex: false,
            codexTab: 'CURRENT',
            saveMessage: null,

            // Player State
            money: INITIAL_MONEY,
            health: INITIAL_HEALTH,
            score: 0,
            coreLevel: 1,
            gameTime: 0,
            difficultyRating: 1,

            // Meta & persistent state - sanitize to ensure only valid upgrade keys
            metaState: (() => {
                const saved = JSON.parse(localStorage.getItem('neon_core_meta_v1'));
                const defaults = {
                    techPoints: 0,
                    prestigeLevel: 0,
                    prestigePoints: 0,
                    unlockedVariants: [],
                    upgrades: {
                        [MetaUpgradeType.STARTING_CASH]: 0,
                        [MetaUpgradeType.CORE_SHIELDING]: 0,
                        [MetaUpgradeType.SCRAP_RECYCLING]: 0,
                        [MetaUpgradeType.TURRET_MASTERY]: 0,
                        [MetaUpgradeType.DISCOUNT_ENGINEERING]: 0
                    }
                };
                if (!saved) return defaults;
                const validKeys = Object.keys(defaults.upgrades);
                const sanitizedUpgrades = {};
                validKeys.forEach(key => { sanitizedUpgrades[key] = saved.upgrades?.[key] ?? 0; });
                return {
                    techPoints: saved.techPoints ?? 0,
                    prestigeLevel: saved.prestigeLevel ?? 0,
                    prestigePoints: saved.prestigePoints ?? 0,
                    unlockedVariants: saved.unlockedVariants ?? [],
                    upgrades: sanitizedUpgrades
                };
            })(),

            // Gameplay Data
            upgrades: {
                [UpgradeType.GLOBAL_DAMAGE]: 0,
                [UpgradeType.GLOBAL_RATE]: 0,
                [UpgradeType.GLOBAL_RANGE]: 0,
                [UpgradeType.MULTISHOT]: 0,
                [UpgradeType.CRIT_CHANCE]: 0,
                [UpgradeType.CRIT_DAMAGE]: 0,
                [UpgradeType.MAX_HEALTH]: 0,
                [UpgradeType.DAMAGE_REDUCTION]: 0,
            },

            // Entities (Mutable containers for performance, updated by loop)
            enemies: [],
            turretVersion: 0,
            getTurrets: () => turretSystem.toArray(),
            texts: [],
            enemyProjectiles: [], // Projectiles fired by SHOOTER enemies (destroyable by click)

            // Hard Mode
            isHardMode: false,

            // Core Systems
            selectedCoreWeapon: CoreWeaponType.LASER,
            activeModules: [],
            moduleCooldowns: {},
            ultimateCharge: 0,
            isPrismaticEnabled: false,
            currentPrismElement: 'FIRE',

            // Infinity Systems
            activeMutations: [],     // Active mutations for current run
            waveNumber: 0,           // Current wave for mutation triggers
            lastMutationWave: 0,     // Last wave a mutation was applied
            evolutionPending: null,  // Turret ID pending evolution choice

            // UI State (moved from React state to eliminate mirror refs)
            mousePos: { x: 0, y: 0 },
            selectedTurretType: null,
            selectedTurretId: null,
            isHoveringCanvas: false,
            isCoreSelected: false,

            // Setters for UI state
            setMousePos: (pos) => set({ mousePos: pos }),
            setSelectedTurretType: (t) => set({ selectedTurretType: t }),
            setSelectedTurretId: (id) => set({ selectedTurretId: id }),
            setIsHoveringCanvas: (v) => set({ isHoveringCanvas: v }),
            setIsCoreSelected: (v) => set({ isCoreSelected: v }),

            // Loop Internals (Refs)
            lastRegenTime: 0,
            coreLastFired: 0,
            simAccumulator: 0,
            lastMinibossSpawn: 0,
            lastBossSpawn: 0,
            nextSpawnTime: 0,
            prismTimer: 0,
            ultActiveTimer: 0,

            // Actions
            setGameState: (s) => set({ gameState: s }),
            setGameSpeed: (s) => {
                // Block pausing in hard mode
                if (s === 0 && get().isHardMode) return;
                set({ gameSpeed: s });
            },
            setShowUpgrades: (v) => set({ showUpgrades: v }),
            setShowTechLab: (v) => set({ showTechLab: v }),
            setShowCodex: (v) => set({ showCodex: v }),
            toggleUpgradeMenu: () => set(s => ({ showUpgrades: !s.showUpgrades })),
            toggleTechLab: () => set(s => ({ showTechLab: !s.showTechLab })),
            toggleCodex: () => set(s => ({ showCodex: !s.showCodex })),
            setCodexTab: (t) => set({ codexTab: t }),

            // @game-reset
            resetGame: () => {
                const meta = get().metaState;
                const upgrades = meta?.upgrades || {};
                const startMoney = INITIAL_MONEY + ((upgrades[MetaUpgradeType.STARTING_CASH] || 0) * 50);
                const startHealth = INITIAL_HEALTH + ((upgrades[MetaUpgradeType.CORE_SHIELDING] || 0) * 25);

                set({
                    gameState: GameStatus.PLAYING,
                    gameSpeed: 1,
                    money: startMoney,
                    health: startHealth,
                    score: 0,
                    coreLevel: 1,
                    gameTime: 0,
                    difficultyRating: 1,
                    enemies: [],
                    texts: [],
                    upgrades: {
                        [UpgradeType.GLOBAL_DAMAGE]: 0,
                        [UpgradeType.GLOBAL_RATE]: 0,
                        [UpgradeType.GLOBAL_RANGE]: 0,
                        [UpgradeType.MULTISHOT]: 0,
                        [UpgradeType.CRIT_CHANCE]: 0,
                        [UpgradeType.CRIT_DAMAGE]: 0,
                        [UpgradeType.MAX_HEALTH]: 0,
                        [UpgradeType.DAMAGE_REDUCTION]: 0,
                    },
                    selectedCoreWeapon: CoreWeaponType.BLASTER,
                    activeModules: [],
                    ultimateCharge: 0,
                    isPrismaticEnabled: false,
                    lastRegenTime: 0,
                    coreLastFired: 0,
                    simAccumulator: 0,
                    nextSpawnTime: 0
                });
                particleSystem.reset();
                projectileSystem.reset();
                enemySystem.count = 0;
                turretSystem.reset();
            },

            actions: {
                addMoney: (n) => set(s => ({ money: s.money + n })),
                damageCore: (n) => set(s => ({ health: Math.max(0, s.health - n) })),
                addScore: (n) => set(s => ({ score: s.score + n })),
                updateMeta: (fn) => set(s => {
                    const newMeta = fn(s.metaState);
                    localStorage.setItem('neon_core_meta_v1', JSON.stringify(newMeta));
                    return { metaState: newMeta };
                })
            }
        }));

        const FIXED_STEP = GAME_CONSTANTS.FIXED_TIMESTEP;

        // ==================== UI COMPONENTS ====================
        const TechUpgradeItem = ({ type, def, level, cost, isMaxed, canAfford, onBuy }) => (
            <div className={`relative p-4 rounded-xl border flex flex-col justify-between transition-all ${isMaxed ? 'bg-emerald-950/30 border-emerald-500/30' : 'bg-slate-800/80 border-slate-600 hover:border-cyan-400/60 hover:shadow-[0_0_20px_rgba(34,211,238,0.2)]'}`}>
                {/* Level indicator bar */}
                <div className="absolute top-0 left-0 right-0 h-1 rounded-t-xl bg-slate-700 overflow-hidden">
                    <div className="h-full bg-gradient-to-r from-cyan-500 to-purple-500 transition-all" style={{ width: `${(level / def.maxLevel) * 100}%` }} />
                </div>
                <div className="pt-2">
                    <div className="flex justify-between items-start mb-3">
                        <h3 className="font-bold text-white font-orbitron text-sm">{def.name}</h3>
                        <span className={`text-[10px] px-2 py-0.5 rounded-full font-bold ${isMaxed ? 'bg-emerald-500/20 text-emerald-400 border border-emerald-500/30' : 'bg-slate-900 text-slate-400 border border-slate-600'}`}>
                            {isMaxed ? '? MAX' : `${level}/${def.maxLevel}`}
                        </span>
                    </div>
                    <p className="text-xs text-slate-400 mb-3 leading-relaxed">{def.description}</p>
                    <div className="bg-slate-900/50 rounded-lg p-2 mb-3 border border-slate-700/50">
                        <div className="text-[10px] text-slate-500 uppercase tracking-wider mb-1">Current Effect</div>
                        <div className="text-sm text-cyan-300 font-mono">{def.effectDescription(level)}</div>
                    </div>
                </div>
                <button onClick={() => onBuy(type)} disabled={!canAfford && !isMaxed}
                    className={`w-full py-2.5 rounded-lg font-bold text-sm tracking-wider transition-all ${isMaxed
                        ? 'bg-emerald-900/30 text-emerald-400 border border-emerald-500/30 cursor-default'
                        : canAfford
                            ? 'bg-gradient-to-r from-cyan-600 to-cyan-500 hover:from-cyan-500 hover:to-cyan-400 text-white shadow-[0_0_15px_rgba(34,211,238,0.3)]'
                            : 'bg-slate-700/50 text-slate-500 border border-slate-600'}`}>
                    {isMaxed ? 'UNLOCKED' : `? ${cost} TP`}
                </button>
            </div>
        );

        const TechLabModal = () => {
            const { showTechLab, setShowTechLab, metaState, gameState, setGameState, actions } = useGameStore(s => ({ ...s, actions: s.actions }));
            if (!showTechLab) return null;
            const buy = (type) => {
                const lvl = metaState.upgrades[type], cost = Math.floor(META_UPGRADE_STATS[type].baseCost * META_UPGRADE_STATS[type].costMultiplier ** lvl);
                if (metaState.techPoints >= cost && lvl < META_UPGRADE_STATS[type].maxLevel) actions.updateMeta(m => ({ ...m, techPoints: m.techPoints - cost, upgrades: { ...m.upgrades, [type]: lvl + 1 } }));
            };
            return (
                <div className="absolute inset-0 bg-black/80 backdrop-blur flex items-center justify-center z-50">
                    <div className="bg-slate-900 w-[800px] h-[600px] rounded-2xl border border-slate-700 overflow-hidden flex flex-col">
                        <div className="p-4 border-b border-slate-800 flex justify-between bg-slate-950">
                            <h2 className="text-xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-500 font-orbitron tracking-wider">TECH LAB</h2>
                            <div className="bg-slate-900 px-4 py-1.5 rounded-full border border-cyan-500/50 text-cyan-300 font-mono shadow-[0_0_10px_rgba(34,211,238,0.2)]">{metaState.techPoints} TP</div>
                        </div>
                        <div className="flex-1 overflow-y-auto p-6 grid grid-cols-2 gap-4">
                            {Object.values(MetaUpgradeType).map(t => {
                                const def = META_UPGRADE_STATS[t], lvl = metaState.upgrades[t] || 0, cost = Math.floor(def.baseCost * def.costMultiplier ** lvl), max = lvl >= def.maxLevel;
                                return <TechUpgradeItem key={t} type={t} def={def} level={lvl} cost={cost} isMaxed={max} canAfford={!max && metaState.techPoints >= cost} onBuy={buy} />;
                            })}
                        </div>
                        <div className="p-4 border-t border-slate-800 bg-slate-950 flex justify-end">
                            <button
                                onClick={() => {
                                    setShowTechLab(false);
                                    if (gameState === GameStatus.GAME_OVER) setGameState(GameStatus.IDLE);
                                }}
                                className="px-6 py-2 bg-slate-800 text-white rounded border border-slate-600 hover:border-cyan-500/50 hover:shadow-[0_0_10px_rgba(34,211,238,0.2)] transition-all"
                            >Close</button>
                        </div>
                    </div>
                </div>
            );
        };

        const CoreWeaponCard = ({ def, isSelected, onClick }) => (
            <button onClick={onClick} className={`w-full text-left p-3 rounded border ${isSelected ? 'bg-red-900/20 border-red-500' : 'bg-slate-800 border-slate-700'}`}>
                <div className="flex justify-between mb-1"><span className={`font-bold ${isSelected ? 'text-white' : 'text-slate-300'}`}>{def.name}</span>{isSelected && <span className="text-[10px] bg-red-600 text-white px-1 rounded">ACTIVE</span>}</div>
                <div className="text-[10px] text-slate-400 mb-1">{def.description}</div>
                <div className="text-[10px] font-mono text-red-300">ULT: {def.ultimateName}</div>
            </button>
        );

        const CoreModuleCard = ({ def, isOwned, onCooldown, cd, money, onBuy }) => (
            <div className={`p-3 rounded border bg-slate-800 ${isOwned ? 'border-emerald-500/50' : 'border-slate-700'}`}>
                <div className="flex justify-between mb-1">
                    <span className="font-bold text-slate-200">{def.name}</span>
                    {isOwned ? <span className={`text-[10px] px-2 rounded ${onCooldown ? 'bg-amber-900/50 text-amber-500' : 'bg-emerald-900/50 text-emerald-500'}`}>{onCooldown ? `${Math.ceil(cd / 1000)}s` : 'READY'}</span> : <span className="text-xs text-amber-300">${def.cost}</span>}
                </div>
                <div className="text-[10px] text-slate-400 mb-2">{def.description}</div>
                {!isOwned && <button onClick={onBuy} disabled={money < def.cost} className={`w-full py-1 text-xs font-bold rounded ${money >= def.cost ? 'bg-amber-600 text-white' : 'bg-slate-700 text-slate-500'}`}>PURCHASE</button>}
            </div>
        );

        const ShopItemTooltip = ({ def, type }) => (
            <div className="absolute bottom-full mb-10 left-1/2 -translate-x-1/2 w-64 bg-slate-900 border border-slate-600 p-4 rounded-xl shadow-2xl pointer-events-none z-50 animate-fade-in-up">
                <div className="flex items-center gap-2 mb-2 border-b border-slate-700 pb-2">
                    <div className="w-3 h-3 rounded-full" style={{ backgroundColor: def.color }} />
                    <span className="font-bold text-white font-orbitron">{def.name}</span>
                </div>
                <div className="text-xs text-slate-400 mb-3">{def.description}</div>

                <div className="space-y-1 mb-3">
                    <div className="flex items-center justify-between text-xs text-slate-500"><span>Damage</span><span className="text-white">{def.stats.damage}</span></div>
                    <div className="w-full h-1 bg-slate-800 rounded overflow-hidden"><div className="h-full bg-red-400" style={{ width: `${def.stats.damage * 10}%` }}></div></div>

                    <div className="flex items-center justify-between text-xs text-slate-500 mt-1"><span>Speed</span><span className="text-white">{def.stats.speed}</span></div>
                    <div className="w-full h-1 bg-slate-800 rounded overflow-hidden"><div className="h-full bg-amber-400" style={{ width: `${def.stats.speed * 10}%` }}></div></div>

                    <div className="flex items-center justify-between text-xs text-slate-500 mt-1"><span>Range</span><span className="text-white">{def.stats.range}</span></div>
                    <div className="w-full h-1 bg-slate-800 rounded overflow-hidden"><div className="h-full bg-cyan-400" style={{ width: `${def.stats.range * 10}%` }}></div></div>
                </div>

                <div className="text-xs text-emerald-400 font-mono">
                    Effect: {def.specialEffect}
                </div>
            </div>
        );

        const ShopItem = ({ type, def, money, cost, onBuy, isLocked, onHover, onLeave, hoveredItem, isSelected }) => {
            const isHovered = hoveredItem === type;
            const canAfford = money >= cost;

            return (
                <div className="relative group" onMouseEnter={() => onHover(type)} onMouseLeave={onLeave}>
                    <button
                        onClick={() => onBuy(type)}
                        disabled={isLocked || !canAfford}
                        className={`relative flex flex-col items-center p-3 rounded-lg border
                            transition-all duration-200 min-w-[90px]
                            ${isSelected
                                ? 'border-cyan-400 bg-slate-800 scale-105 shadow-[0_0_8px_rgba(34,211,238,0.3)]'
                                : 'border-slate-700 bg-slate-800'}
                            ${(!canAfford || isLocked) ? 'opacity-50 grayscale' : 'hover:border-cyan-500/40'} `}
                    >
                        <div className="w-10 h-10 mb-2 rounded-full flex items-center justify-center transition-all group-hover:scale-110" style={{ backgroundColor: def.color }}>
                            {def.icon && <def.icon className={`w-5 h-5 ${type === TurretType.SHOCK ? 'text-yellow-200' : 'text-white'} `} />}
                        </div>
                        <div className="font-bold text-[10px] text-white uppercase tracking-tighter">{def.name}</div>
                        <div className="text-[10px] font-mono font-bold text-amber-300">${cost}</div>
                    </button>
                    {isHovered && !isLocked && <ShopItemTooltip def={def} type={type} />}
                </div>
            );
        };

        const UpgradeCard = ({ type, stats, currentLevel, cost, money, onBuy }) => (
            <div className="relative bg-slate-800/80 p-3 rounded-lg border border-slate-600 hover:border-purple-400/60 hover:shadow-[0_0_15px_rgba(168,85,247,0.15)] transition-all group">
                {/* Level progress bar */}
                <div className="absolute top-0 left-0 right-0 h-0.5 bg-slate-700 rounded-t-lg overflow-hidden">
                    <div className="h-full bg-gradient-to-r from-purple-500 to-pink-500" style={{ width: `${Math.min(currentLevel * 10, 100)}%` }} />
                </div>
                <div className="flex justify-between items-center mb-2 pt-1">
                    <div className="font-bold text-sm text-white">{stats.name}</div>
                    <div className="flex items-center gap-2">
                        <div className="text-[10px] bg-purple-900/40 px-2 py-0.5 rounded-full text-purple-300 border border-purple-500/30">Lv {currentLevel}</div>
                    </div>
                </div>
                <div className="text-[11px] text-slate-400 mb-2">{stats.description}</div>
                <div className="flex justify-between items-center gap-2 bg-slate-900/50 rounded p-2 border border-slate-700/50">
                    <div className="text-xs text-emerald-400 font-mono">{stats.effectDescription(currentLevel)}</div>
                    <button onClick={() => onBuy(type)} disabled={money < cost}
                        className={`px-4 py-1.5 rounded-lg font-bold text-xs whitespace-nowrap transition-all ${money >= cost
                            ? 'bg-gradient-to-r from-purple-600 to-purple-500 hover:from-purple-500 hover:to-purple-400 text-white shadow-[0_0_10px_rgba(168,85,247,0.3)]'
                            : 'bg-slate-700 text-slate-500'}`}>
                        ${cost}
                    </button>
                </div>
            </div>
        );

        const CoreMainframeTab = ({ coreLevel, money, upgradeCore }) => (
            <div className="space-y-4">
                <div className="bg-slate-800 p-3 rounded border border-slate-700">
                    <div className="text-xs text-slate-400 mb-1">CORE STATUS</div>
                    <div className="flex justify-between mb-2"><span className="text-sm font-bold text-white">INTEGRITY</span><span className="text-sm font-mono text-emerald-400">100%</span></div>
                    <div className="w-full h-1.5 bg-slate-900 rounded-full overflow-hidden"><div className="h-full bg-emerald-500 w-full animate-pulse"></div></div>
                </div>
                <div className="bg-slate-800 p-3 rounded border border-slate-700">
                    <div className="flex justify-between mb-2"><span className="text-xs text-slate-400">NEXT UPGRADE</span>{coreLevel < 6 && <span className="text-xs font-mono text-amber-400">${CORE_UPGRADE_COSTS[coreLevel]}</span>}</div>
                    {coreLevel < 6 ? <>
                        <div className="text-xs text-cyan-300 mb-3">{CORE_UPGRADES[coreLevel].description}</div>
                        <div className="space-y-1 mb-3">{CORE_UPGRADES[coreLevel].benefits.map((b, i) => <div key={i} className="flex gap-2 text-[10px] text-slate-300"><div className="w-1 h-1 bg-cyan-500 rounded-full"></div>{b}</div>)}</div>
                        <button onClick={upgradeCore}
                            disabled={money < CORE_UPGRADE_COSTS[coreLevel]}
                            className={`w-full py-2 rounded font-bold text-xs flex justify-center gap-2
                                ${money >= CORE_UPGRADE_COSTS[coreLevel]
                                    ? 'bg-cyan-700 text-white'
                                    : 'bg-slate-700 text-slate-500'}`}
                        ><Zap className="w-3" /> UPGRADE SYSTEM</button>
                    </> : <div className="text-center py-4 text-emerald-400 font-bold text-sm border border-emerald-900/50 bg-emerald-900/20 rounded">MAXIMUM LEVEL REACHED</div>}
                </div>
            </div>
        );

        const CoreMenu = ({ spawnParticles }) => {
            const { money, activeModules, moduleCooldowns, selectedCoreWeapon, coreLevel, isCoreSelected, setIsCoreSelected } = useGameStore(s => ({ ...s, setIsCoreSelected: s.setIsCoreSelected }));
            const [tab, setTab] = useState('MAINFRAME');

            if (!isCoreSelected) return null;

            const spawnText = (x, y, text, color) => useGameStore.getState().texts.push({ id: Math.random().toString(), x, y: y - 10, text, color, size: 24, vy: -1, life: 40 });
            // @core-upgrade
            const upgrade = () => {
                const cost = CORE_UPGRADE_COSTS[coreLevel];
                if (coreLevel < 6 && money >= cost) {
                    useGameStore.setState(s => ({ money: s.money - cost, coreLevel: s.coreLevel + 1 }));
                    spawnParticles(window.innerWidth / 2, window.innerHeight / 2, '#0ea5e9', 20);
                    spawnText(window.innerWidth / 2, window.innerHeight / 2, "CORE UPGRADED", '#fff');
                }
            };
            const buyMod = (m) => {
                const cost = CORE_MODULE_DEFS[m].cost;
                if (money >= cost && !activeModules.includes(m)) useGameStore.setState(s => ({ money: s.money - cost, activeModules: [...s.activeModules, m] }));
            };

            return (
                <div className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-80 bg-slate-900 border border-slate-700 rounded-xl p-5 shadow-2xl z-30 flex flex-col h-[500px]">
                    <div className="flex justify-between mb-4 border-b border-slate-700 pb-2">
                        <div>
                            <h3 className="text-lg font-bold text-cyan-400 flex gap-2 font-orbitron">
                                <Hexagon className="w-5" /> NEON CORE
                            </h3>
                            <div className="text-xs text-slate-500 font-mono">SYSTEM LEVEL: {coreLevel}</div>
                        </div>
                        <button onClick={() => setIsCoreSelected(false)} className="text-slate-500 hover:text-white"><X className="w-5" /></button>
                    </div>
                    <div className="flex gap-1 mb-3">
                        {['MAINFRAME', 'ARMORY', 'MODULES'].map(t =>
                            <button key={t} onClick={() => setTab(t)}
                                className={`flex-1 py-1 text-[10px] font-bold border-b-2 ${tab === t ? 'border-cyan-400 text-cyan-400' : 'border-slate-700 text-slate-500'}`}
                            >{t}</button>
                        )}
                    </div>
                    <div className="flex-1 overflow-y-auto pr-1 custom-scrollbar">
                        {tab === 'MAINFRAME' && <CoreMainframeTab coreLevel={coreLevel} money={money} upgradeCore={upgrade} />}
                        {tab === 'ARMORY' && (coreLevel >= 5
                            ? <div className="space-y-2">
                                {Object.values(CoreWeaponType).map(w =>
                                    <CoreWeaponCard key={w} def={CORE_WEAPON_DEFS[w]}
                                        isSelected={selectedCoreWeapon === w}
                                        onClick={() => useGameStore.setState({ selectedCoreWeapon: w })} />
                                )}
                            </div>
                            : <div className="flex flex-col items-center justify-center h-40 text-slate-500">
                                <Lock className="w-8 mb-2 opacity-50" />
                                <div className="text-xs">ARMORY LOCKED</div>
                                <div className="text-[10px]">Reach Core Level 5</div>
                            </div>
                        )}
                        {tab === 'MODULES' && <div className="space-y-3">
                            {Object.values(CoreModuleType).map(m =>
                                <CoreModuleCard key={m}
                                    def={CORE_MODULE_DEFS[m]}
                                    isOwned={activeModules.includes(m)}
                                    onCooldown={(moduleCooldowns[m] || 0) > 0}
                                    cd={moduleCooldowns[m]}
                                    money={money}
                                    onBuy={() => buyMod(m)} />
                            )}
                        </div>}
                    </div>
                </div>
            );
        };

        const TurretDetailPanel = ({ spawnParticles }) => {
            const { selectedTurretId, money, upgrades, actions, turretVersion, setSelectedTurretId } = useGameStore(s => ({ ...s, actions: s.actions }));
            const tData = React.useMemo(() => { const i = turretSystem.findById(selectedTurretId); return i !== -1 ? turretSystem.getSnapshot(i) : null; }, [selectedTurretId, turretVersion]);
            const [, setTick] = useState(0);
            const [hoveredEvo, setHoveredEvo] = useState(null);
            useEffect(() => { const h = () => setTick(t => t + 1); window.addEventListener('resize', h); return () => window.removeEventListener('resize', h); }, []);

            if (!selectedTurretId || !tData) return null;

            const stats = TURRET_STATS[tData.type];
            const effDmg = Math.round(stats.damage * (1 + upgrades[UpgradeType.GLOBAL_DAMAGE] * 0.1));
            const effRng = Math.round(stats.range * (1 + upgrades[UpgradeType.GLOBAL_RANGE] * 0.1));
            const effRate = Math.round(1000 / (stats.cooldown / (1 + upgrades[UpgradeType.GLOBAL_RATE] * 0.1)) * 10) / 10;
            // @turret-sell
            const sell = () => {
                const idx = turretSystem.findById(selectedTurretId);
                if (idx !== -1) {
                    useGameStore.setState(s => ({
                        money: s.money + Math.floor(turretSystem.get(idx).cost * SELL_REFUND_RATIO),
                        turretVersion: s.turretVersion + 1
                    }));
                    turretSystem.remove(idx);
                    spawnParticles(tData.x, tData.y, '#ffd700', 10);
                    setSelectedTurretId(null);
                }
            };
            // @turret-targeting
            const setMode = (m) => {
                const idx = turretSystem.findById(selectedTurretId);
                if (idx !== -1) {
                    turretSystem.items[idx].targetingMode = m;
                    useGameStore.setState(s => ({ turretVersion: s.turretVersion + 1 }));
                }
            };

            // @turret-evolve
            const applyEvolution = (evoType) => {
                const idx = turretSystem.findById(selectedTurretId);
                if (idx === -1) return;
                const evoDef = EVOLUTION_STATS[evoType];
                const t = turretSystem.items[idx];
                t.type = evoType;
                t.killCount = 0;
                t.color = RenderSystem.hexToNum(evoDef.color);
                turretSystem.dirty = true;
                useGameStore.setState(s => ({ money: s.money - evoDef.cost, turretVersion: s.turretVersion + 1 }));
                spawnParticles(tData.x, tData.y, evoDef.color, 20, 2);
                setSelectedTurretId(null);
            };

            const { w, h } = { w: window.innerWidth, h: window.innerHeight };
            const pos = { left: tData.x > w / 2 ? 'auto' : tData.x + 40, right: tData.x > w / 2 ? w - tData.x + 40 : 'auto', top: Math.max(80, Math.min(tData.y - 150, h - 400)) };

            return (
                <div className="absolute w-72 bg-gradient-to-b from-slate-900 to-slate-950 border border-slate-600 rounded-lg p-3 shadow-2xl z-50" style={pos}>
                    <div className="flex justify-between mb-2 border-b border-slate-700 pb-2">
                        <h3 className="text-sm font-bold text-white flex gap-2">
                            <div className="w-3 h-3 rounded-full shadow-[0_0_8px]" style={{ backgroundColor: stats.color }} />
                            {stats.name}
                        </h3>
                        <button onClick={() => setSelectedTurretId(null)} className="text-slate-500 hover:text-white">
                            <X className="w-4" />
                        </button>
                    </div>
                    <div className="space-y-2">
                        <div className="flex justify-between p-2 rounded border border-slate-700 bg-slate-800/30">
                            <div className="text-emerald-400 text-xs"><span className="text-slate-400">Kills:</span> <b>{tData.killCount}</b></div>
                        </div>
                        <div className="bg-slate-800/50 p-2 rounded space-y-1">
                            {[
                                { l: 'Dmg', i: Flame, c: 'text-red-400', v: effDmg, p: effDmg / 2, g: 'from-red-500 to-orange-400' },
                                { l: 'Rng', i: Target, c: 'text-cyan-400', v: effRng, p: effRng / 5, g: 'from-cyan-500 to-blue-400' },
                                { l: 'Spd', i: Zap, c: 'text-amber-400', v: effRate, p: effRate * 10, g: 'from-amber-500 to-yellow-400' }
                            ].map(x =>
                                <div key={x.l} className="flex justify-between">
                                    <div className={`flex gap-1 ${x.c}`}>
                                        <x.i className="w-3" />
                                        <span className="text-[10px]">{x.l}</span>
                                    </div>
                                    <div className="flex gap-1">
                                        <div className="w-16 h-1 bg-slate-700 rounded overflow-hidden">
                                            <div className={`h-full bg-gradient-to-r ${x.g}`}
                                                style={{ width: `${Math.min(100, x.p)}%` }} />
                                        </div>
                                        <span className="text-white font-mono text-[10px] w-6 text-right">{x.v}</span>
                                    </div>
                                </div>
                            )}
                        </div>
                        {tData.type !== TurretType.PRISM &&
                            <div className="flex gap-2 bg-slate-800/50 p-2 rounded">
                                <Crosshair className="w-3 text-slate-400" />
                                <select value={tData.targetingMode} onChange={e => setMode(e.target.value)}
                                    className="flex-1 bg-slate-900 border border-slate-600 text-white text-xs rounded px-2">
                                    <option value="CLOSEST">CLOSEST</option>
                                    <option value="FIRST">FIRST</option>
                                    <option value="LAST">LAST</option>
                                    <option value="STRONG">STRONG</option>
                                    <option value="WEAK">WEAK</option>
                                </select>
                            </div>
                        }

                        {/* Evolution Option - money-based, available if turret has evolution paths */}
                        {EVOLUTION_PATHS[tData.type] && (
                            <div className="bg-gradient-to-r from-purple-900/40 to-pink-900/40 border border-purple-500/40 p-2 rounded">
                                <div className="text-xs text-purple-300 font-bold mb-1">⚡ EVOLVE</div>
                                <div className="text-[10px] text-slate-400 mb-2">Choose a new form</div>
                                <div className="flex gap-2">
                                    {EVOLUTION_PATHS[tData.type].map(evo => {
                                        const evoDef = EVOLUTION_STATS[evo];
                                        const canAffordEvo = money >= evoDef.cost;
                                        return (
                                            <button key={evo}
                                                onClick={() => canAffordEvo && applyEvolution(evo)}
                                                disabled={!canAffordEvo}
                                                onMouseEnter={() => setHoveredEvo(evo)}
                                                onMouseLeave={() => setHoveredEvo(null)}
                                                className={`flex-1 flex flex-col items-center justify-center py-1.5 rounded font-bold border transition-all ${canAffordEvo ? 'bg-purple-800/50 border-purple-500/50 text-purple-200 hover:bg-purple-700/50 hover:shadow-[0_0_8px_rgba(168,85,247,0.4)]' : 'bg-slate-800/50 border-slate-600/50 text-slate-500 cursor-not-allowed'}`}
                                            >
                                                <div className="text-[10px] whitespace-nowrap">{evoDef.name}</div>
                                                <div className="text-[9px] opacity-70">${evoDef.cost}</div>
                                            </button>
                                        );
                                    })}
                                </div>
                                {/* Dynamic Evolution Details */}
                                <div className="mt-2 text-left min-h-[60px] p-2 bg-slate-900/60 rounded border border-purple-500/20 transition-all duration-200">
                                    {hoveredEvo ? (() => {
                                        const evoDefPrice = EVOLUTION_STATS[hoveredEvo];
                                        const evoDef = TURRET_STATS[hoveredEvo];
                                        return (
                                            <div className="animate-fade-in">
                                                <div className="text-xs text-purple-300 font-bold mb-1 flex justify-between">
                                                    <span>{evoDefPrice.name}</span>
                                                    <span className="text-emerald-400">{evoDef?.specialEffect || evoDefPrice.desc}</span>
                                                </div>
                                                <div className="text-[10px] text-slate-300 mb-1 leading-tight">{evoDef?.description || evoDefPrice.desc}</div>
                                                <div className="flex justify-between items-center text-[9px] text-slate-400">
                                                    <span>DMG: {evoDef?.displayStats?.damage || evoDef?.damage || '0'}</span>
                                                    <span>RNG: {evoDef?.displayStats?.range || evoDef?.range || '0'}</span>
                                                    <span>SPD: {evoDef?.displayStats?.speed || '0'}</span>
                                                </div>
                                            </div>
                                        );
                                    })() : (
                                        <div className="h-full flex items-center justify-center text-[10px] text-slate-500 italic">
                                            Hover an evolution to view details
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}

                        <div className="flex gap-2">
                            <button onClick={sell} className="flex-1 py-1 bg-slate-800 hover:text-red-400 text-slate-500 rounded flex justify-center gap-1 border border-slate-700 text-xs font-bold"><Trash2 className="w-3" /> SELL (${Math.floor(tData.cost * SELL_REFUND_RATIO)})</button>
                        </div>
                    </div>
                </div>
            );
        };

        const UpgradesPanel = () => {
            const { showUpgrades, upgrades, money } = useGameStore(s => ({ showUpgrades: s.showUpgrades, upgrades: s.upgrades, money: s.money }));
            if (!showUpgrades) return null;
            const buy = (type) => {
                const cost = Math.floor(UPGRADE_STATS[type].baseCost * UPGRADE_STATS[type].costMultiplier ** upgrades[type]);
                if (money >= cost) useGameStore.setState(s => ({ money: s.money - cost, upgrades: { ...s.upgrades, [type]: s.upgrades[type] + 1 }, health: type === UpgradeType.MAX_HEALTH ? s.health + 25 : s.health }));
            };
            return (
                <div className="absolute right-8 top-24 bottom-24 w-80 bg-slate-900 border border-purple-500/30 rounded-lg p-4 overflow-y-auto z-30 shadow-[0_0_20px_rgba(168,85,247,0.15)]">
                    <h2 className="text-base font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-400 mb-3 flex gap-2 border-b border-slate-700 pb-2 font-orbitron tracking-wider">
                        <Cpu className="text-purple-400 w-4" /> MODS
                    </h2>
                    <div className="space-y-2">
                        {Object.values(UpgradeType).map(t =>
                            <UpgradeCard key={t} type={t} stats={UPGRADE_STATS[t]}
                                currentLevel={upgrades[t]}
                                cost={Math.floor(UPGRADE_STATS[t].baseCost * UPGRADE_STATS[t].costMultiplier ** upgrades[t])}
                                money={money} onBuy={buy} />
                        )}
                    </div>
                </div>
            );
        };

        const BuildMenu = () => {
            const { money, selectedTurretType, metaState, setSelectedTurretType, setShowUpgrades, setSelectedTurretId, setIsCoreSelected } = useGameStore(s => ({ ...s, setSelectedTurretType: s.setSelectedTurretType }));
            const [cat, setCat] = useState('KINETIC');
            const [hover, setHover] = useState(null);

            return (
                <div className="absolute bottom-0 left-1/2 -translate-x-1/2 flex flex-col items-center z-30 group translate-y-[55%] hover:translate-y-0 transition-transform duration-300 pb-0 pt-16">
                    <div className="flex justify-center mb-[-1px] z-10 relative">
                        {['KINETIC', 'ELEMENTAL', 'HEAVY', 'SUPPORT'].map(c =>
                            <button key={c} onClick={() => setCat(c)}
                                className={`px-3 py-1.5 text-[10px] font-bold rounded-t-lg border-t border-x ${cat === c
                                    ? 'bg-slate-900 text-white border-slate-600 border-b-slate-900'
                                    : 'bg-slate-800 text-slate-500 border-slate-700'}`}
                            >{c}</button>
                        )}
                    </div>
                    <div className="flex gap-4 bg-slate-900 p-3 rounded-t-xl border border-slate-700 shadow-xl relative z-0 min-w-[400px] justify-center">
                        {Object.values(TurretType).filter(t => TURRET_STATS[t].category === cat).map(t => {
                            const stats = TURRET_STATS[t], coste = Math.floor(stats.cost * (1 - (metaState?.upgrades?.[MetaUpgradeType.DISCOUNT_ENGINEERING] || 0) * 0.02));
                            const afford = money >= coste;
                            return (
                                <div key={t} className="w-24">
                                    <ShopItem type={t} def={stats} money={money} cost={coste} isLocked={false} onHover={setHover} onLeave={() => setHover(null)} hoveredItem={hover} isSelected={selectedTurretType === t}
                                        onBuy={() => { if (afford) { setSelectedTurretType(t); setShowUpgrades(false); setSelectedTurretId(null); setIsCoreSelected(false); } }} />
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        const CodexModal = () => {
            const {
                showCodex,
                onClose,
                codexTab,
                setCodexTab,
                gameTime
            } = useGameStore(s => ({
                showCodex: s.showCodex,
                onClose: () => s.setShowCodex(false),
                codexTab: s.codexTab,
                setCodexTab: s.setCodexTab,
                gameTime: s.gameTime
            }), shallowStr);
            if (!showCodex) return null;
            const enemies = [];
            for (let i = 0; i < enemySystem.count; i++) {
                enemies.push({
                    id: enemySystem.ids[i],
                    type: enemySystem.type[i],
                    hp: enemySystem.hp[i],
                    maxHp: enemySystem.maxHp[i],
                    color: numToHex(enemySystem.color[i]),
                    frozen: enemySystem.frozen[i],
                    burn: enemySystem.burn[i],
                    poison: enemySystem.poison[i]
                });
            }

            return (
                <div className="absolute inset-0 bg-black/80 backdrop-blur flex items-center justify-center z-50">
                    <div className="bg-slate-900 w-[900px] h-[650px] rounded-2xl border border-slate-700 overflow-hidden flex flex-col">
                        <div className="p-4 border-b border-slate-800 flex justify-between items-center bg-slate-950">
                            <h2 className="text-2xl font-bold font-orbitron text-cyan-400">CODEX</h2>
                            <button onClick={onClose} className="text-slate-500 hover:text-white">
                                <X className="w-6" />
                            </button>
                        </div>
                        <div className="flex border-b border-slate-800 bg-slate-950/50">
                            {[
                                { id: 'CURRENT', l: 'Current Enemies', i: Activity },
                                { id: 'TYPES', l: 'Enemy Types', i: Hexagon },
                                { id: 'EFFECTS', l: 'Status Effects', i: Flame },
                                { id: 'COMBOS', l: 'Combos', i: Zap },
                                { id: 'TRAITS', l: 'Traits', i: Shield }
                            ].map(t =>
                                <button key={t.id} onClick={() => setCodexTab(t.id)}
                                    className={`flex-1 py-3 px-4 flex justify-center gap-2 ${codexTab === t.id
                                        ? 'text-cyan-400 border-b-2 border-cyan-400'
                                        : 'text-slate-500'}`}
                                ><t.i className="w-4" />{t.l}</button>
                            )}
                        </div>
                        <div className="flex-1 overflow-y-auto p-6">
                            {codexTab === 'CURRENT' && (enemies.length ? <div className="grid grid-cols-2 gap-3">{enemies.slice(0, 20).map(e => (
                                <div key={e.id} className="bg-slate-800 p-3 rounded border border-slate-700 flex items-center gap-3">
                                    <div className="w-8 h-8 rounded-full flex justify-center items-center" style={{ backgroundColor: ENEMY_STATS[e.type]?.color || e.color }}><Hexagon className="w-4 text-white" /></div>
                                    <div className="flex-1">
                                        <div className="text-sm font-bold text-white">{e.type}</div>
                                        <div className="flex items-center gap-2">
                                            <div className="flex-1 h-1 bg-slate-700 rounded overflow-hidden">
                                                <div className="h-full bg-red-500" style={{ width: `${(e.hp / e.maxHp) * 100}%` }} />
                                            </div>
                                            <span className="text-xs text-slate-400">{Math.ceil(e.hp)}/{e.maxHp}</span>
                                        </div>
                                    </div>
                                    {e.frozen > 0 && <Snowflake className="w-4 text-cyan-400" />} {e.burn > 0 && <Flame className="w-4 text-orange-400" />} {e.poison > 0 && <Biohazard className="w-4 text-lime-400" />}
                                </div>
                            ))}</div> : <div className="text-center text-slate-600 py-12">No enemies on field</div>)}
                            {codexTab === 'TYPES' && (() => {
                                const mult = 1 + (Math.floor((gameTime || 0) / 45000) * 0.2);
                                return <div className="space-y-4"><div className="text-sm text-slate-400">HP Multiplier: <span className="text-red-400 font-bold">{mult.toFixed(1)}x</span></div><div className="grid grid-cols-2 gap-4">{Object.entries(ENEMY_STATS).map(([t, s]) => (
                                    <div key={t} className="bg-slate-800 p-3 rounded border border-slate-700">
                                        <div className="flex gap-3 mb-2">
                                            <div className="w-10 h-10 rounded-full flex justify-center items-center"
                                                style={{ backgroundColor: s.color }}>
                                                <Hexagon className="w-5 text-white" />
                                            </div>
                                            <div>
                                                <div className="font-bold text-white">{s.name || t}</div>
                                                <div className="text-[10px] text-slate-500">HP: {s.hp} | $: {s.reward}</div>
                                            </div>
                                        </div>
                                        <div className="grid grid-cols-3 gap-2 text-xs text-center">
                                            <div className="bg-slate-900 p-1 rounded">
                                                <div className="text-red-400 font-bold">{Math.round(s.hp * mult)}</div>HP
                                            </div>
                                            <div className="bg-slate-900 p-1 rounded">
                                                <div className="text-yellow-400 font-bold">{s.speed.toFixed(2)}</div>SPD
                                            </div>
                                            <div className="bg-slate-900 p-1 rounded">
                                                <div className="text-amber-400 font-bold">{s.radius}</div>SZ
                                            </div>
                                        </div>
                                    </div>
                                ))}</div></div>;
                            })()}
                            {codexTab === 'EFFECTS' && <div className="grid grid-cols-3 gap-6">{CODEX_DATA.EFFECTS.map(e => <CodexCard key={e.id || e.title} title={e.title} icon={e.icon} iconBgClass={e.iconBgClass} description={e.description}>{CodexVisuals[e.visual]}</CodexCard>)}</div>}
                            {codexTab === 'COMBOS' && <div className="grid grid-cols-2 gap-4">{CODEX_DATA.COMBOS.map(c => <CodexCard key={c.title} title={c.title} icon={c.icon} iconBgClass={c.iconBgClass} description={c.description}>{CodexVisuals[c.visual]}</CodexCard>)}</div>}
                            {codexTab === 'TRAITS' && <div className="grid grid-cols-3 gap-6">{CODEX_DATA.TRAITS.map(t => <CodexCard key={t.id} title={t.name} icon={t.icon} iconBgClass={`bg-${t.color}-500`} description={t.description}>{CodexVisuals[t.visual]}</CodexCard>)}</div>}
                        </div>
                    </div>
                </div>
            );
        };

        const GameOverlays = ({ earnedTechPoints }) => {
            const {
                gameState,
                showTechLab,
                gameSpeed,
                setShowTechLab,
                resetGame
            } = useGameStore(s => ({ ...s, setShowTechLab: s.setShowTechLab, resetGame: s.resetGame }));
            // @game-start
            const startGame = (hard) => {
                useGameStore.setState({ isHardMode: hard });
                resetGame();
            };

            if (gameSpeed === 0 && gameState === GameStatus.PLAYING) return (
                <div className="absolute inset-0 flex items-center justify-center z-20 pointer-events-none"><div className="bg-black/40 backdrop-blur-sm px-8 py-4 border-y border-amber-500/50 text-amber-400 font-orbitron text-2xl tracking-[0.2em] animate-pulse">SIMULATION PAUSED</div></div>
            );

            if (gameState === GameStatus.IDLE && !showTechLab) return (
                <div className="absolute inset-0 bg-black/80 backdrop-blur flex items-center justify-center z-50">
                    <div className="text-center max-w-2xl px-6">
                        <h1 className="text-7xl font-black text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-purple-500 to-pink-500 mb-4 font-orbitron tracking-tighter drop-shadow-[0_0_20px_rgba(168,85,247,0.6)]">INFINITY TD</h1>
                        <p className="text-slate-400 mb-10 text-lg">Endless waves. Infinite challenge.</p>
                        <div className="flex flex-col items-center gap-4">
                            <div className="flex justify-center gap-6">
                                <NeonButton onClick={() => startGame(false)} color="white"
                                    className="px-10 py-4 text-xl tracking-widest text-black">
                                    Start Game
                                </NeonButton>
                                <NeonButton onClick={() => startGame(true)} color="red"
                                    className="px-10 py-4 text-xl tracking-widest">
                                    Hard Mode
                                </NeonButton>
                            </div>
                            <NeonButton onClick={() => setShowTechLab(true)} color="slate" icon={Database} className="px-8 py-3 text-lg tracking-widest text-cyan-300 border-slate-600">Tech Lab</NeonButton>
                        </div>
                    </div>
                </div>
            );

            if (gameState === GameStatus.GAME_OVER && !showTechLab) {
                const gameTime = useGameStore.getState().gameTime || 0;
                const canPrestige = gameTime >= 600000; // 10 minutes
                const score = useGameStore.getState().score || 0;
                const prestigeGain = canPrestige ? Math.floor(score / 1000) + 1 : 0;

                const doPrestige = () => {
                    useGameStore.setState(s => ({
                        metaState: {
                            ...s.metaState,
                            prestigeLevel: s.metaState.prestigeLevel + 1,
                            prestigePoints: s.metaState.prestigePoints + prestigeGain
                        }
                    }));
                    // Save to localStorage
                    const meta = useGameStore.getState().metaState;
                    localStorage.setItem('neon_core_meta_v1', JSON.stringify(meta));
                    resetGame();
                };

                return (
                    <div className="absolute inset-0 bg-red-950/90 backdrop-blur flex items-center justify-center z-50 animate-fade-in">
                        <div className="text-center p-12 bg-black/40 rounded-3xl border border-red-900/50 shadow-2xl">
                            <h1 className="text-6xl font-black text-white mb-2 font-orbitron tracking-tighter">CRITICAL FAILURE</h1>
                            <div className="text-xl text-red-400 mb-6 font-mono tracking-widest">SYSTEM COMPROMISED</div>

                            <div className="flex items-center justify-center gap-3 bg-gradient-to-r from-transparent via-blue-900/30 to-transparent py-4 mb-4">
                                <Database className="text-cyan-400" /><span className="text-cyan-200">Data Salvaged:</span>
                                <span className="text-2xl font-bold text-white font-mono">+{earnedTechPoints} TP</span>
                            </div>

                            {canPrestige && (
                                <div className="mb-6 p-4 bg-gradient-to-r from-purple-900/30 via-pink-900/30 to-purple-900/30 rounded-lg border border-purple-500/30">
                                    <div className="text-purple-300 text-sm mb-2">PRESTIGE AVAILABLE</div>
                                    <div className="text-white font-bold">+{prestigeGain} Prestige Points</div>
                                    <div className="text-xs text-slate-400 mt-1">Reset progress, keep Tech Lab upgrades</div>
                                </div>
                            )}

                            <div className="flex justify-center gap-4">
                                <NeonButton onClick={resetGame} color="red" className="px-8 shadow-red-900/40">REBOOT</NeonButton>
                                {canPrestige && <NeonButton onClick={doPrestige} color="purple" className="px-8">PRESTIGE</NeonButton>}
                                <NeonButton onClick={() => setShowTechLab(true)} color="slate" icon={Database} className="px-8 text-cyan-400 border-slate-600">TECH LAB</NeonButton>
                            </div>
                        </div>
                    </div>
                );
            }
            return null;
        };

        // ==================== ENTITY SYSTEMS (RUNTIME DATA) ====================
        // Enemy SoA shape: ids, x, y, vx, vy, hp, maxHp, speed, radius,
        //   reward, type, color, frozen, burn, poison, stunned, lastFired, traits
        const EnemyBase = new SoABuilder(GAME_CONSTANTS.ENEMY_SYSTEM_CAPACITY)
            .addArray('ids').addFloat('x').addFloat('y').addFloat('vx').addFloat('vy')
            .addFloat('hp').addFloat('maxHp').addFloat('speed').addFloat('radius')
            .addUint16('reward').addArray('type').addArray('color')
            .addFloat('frozen').addFloat('burn').addFloat('poison').addFloat('stunned')
            .addFloat('lastFired', -1000).addArray('traits', null)
            .build();
        class EnemySystem extends EnemyBase {
            constructor() {
                super();
                this._idCounter = 0;
                Object.defineProperty(this.flyweight, 'id', {
                    get() { return this.sys.ids[this.index]; },
                    enumerable: true, configurable: true
                });
            }
            spawn(data) {
                data.ids = data.id ?? ++this._idCounter;
                data.traits = data.traits || [];
                return super.spawn(data);
            }
            remove(index) {
                super.remove(index);
                const tail = this.count;
                this.ids[tail] = null;
                this.traits[tail] = null;
                this.type[tail] = null;
                this.color[tail] = null;
            }
        }
        const enemySystem = new EnemySystem(GAME_CONSTANTS.ENEMY_SYSTEM_CAPACITY);

        /**
         * Turret system - manages turrets as plain objects.
         * Turret shape: { id, type, targetingMode, x, y, hp, maxHp,
         *   lastFired, killCount, charge, color, radius, cost,
         *   spawnTime, range, damage, cooldown }
         */
        const turretSystem = {
            items: [],
            dirty: false,
            _idCounter: 0,
            get count() { return this.items.length; },

            spawn(data) {
                const turret = {
                    id: data.id ?? ++this._idCounter,
                    type: data.type,
                    targetingMode: data.targetingMode ?? TargetingMode.CLOSEST,
                    x: data.x || 0, y: data.y || 0,
                    hp: data.hp ?? 100, maxHp: data.maxHp ?? data.hp ?? 100,

                    lastFired: data.lastFired ?? 0,
                    killCount: data.killCount ?? 0,
                    charge: data.charge ?? 0,
                    color: typeof data.color === 'string' ? hexToNum(data.color) : (data.color || 0x22d3ee),
                    radius: data.radius ?? 20,
                    cost: data.cost ?? 0,
                    spawnTime: data.spawnTime ?? 0,
                    range: data.range, damage: data.damage, cooldown: data.cooldown
                };
                this.items.push(turret);
                this.dirty = true;
                return turret;
            },

            get(i) { return this.items[i]; },
            remove(i) {
                this.items.splice(i, 1);
                this.dirty = true;
            },

            findById(id) { return this.items.findIndex(t => t.id === id); },

            getSnapshot(i) {
                const t = this.items[i];
                return { ...t, color: numToHex(t.color) };
            },

            reset() { this.items.length = 0; this.dirty = true; this._idCounter = 0; },
            toArray() { return [...this.items]; }
        };
        // ==================== GAME MANAGERS (RUNTIME CONTROLLERS) ====================
        /** Manages turret targeting, firing, and special abilities */
        class TurretManager {
            constructor() {
                // Persistent context to avoid per-frame allocation
                this.ctx = {
                    state: null,
                    tree: null,
                    dims: null,
                    spawnProjectile: null,
                    spawnParticles: null,
                    spawnSingleParticle: null,
                    spawnFloatingText: null,
                    spawnRailgunBeam: null,
                    spawnLightning: null,
                    getDistanceSq: null,
                    stats: null,
                    // Static refs
                    EnemyTrait,
                    Vec,
                    UpgradeType,
                    TURRET_STATS,
                    FIXED_STEP
                };
            }

            update(state, tree, dims, callbacks) {
                // Update persistent context
                this.ctx.state = state;
                this.ctx.tree = tree;
                this.ctx.dims = dims;
                this.ctx.spawnProjectile = callbacks.spawnProjectile;
                this.ctx.spawnParticles = callbacks.spawnParticles;
                this.ctx.spawnDirectional = callbacks.spawnDirectional;
                this.ctx.spawnSingleParticle = callbacks.spawnSingleParticle;
                this.ctx.spawnFloatingText = callbacks.spawnFloatingText;
                this.ctx.spawnRailgunBeam = callbacks.spawnRailgunBeam;
                this.ctx.spawnLightning = callbacks.spawnLightning;
                this.ctx.getDistanceSq = callbacks.getDistanceSq;

                // Helper for behavior context (behaviors expect 'getTurretEffectiveStats' to be available or result used)
                // The original code passed 'stats' in ctx.
                const { getTurretEffectiveStats } = callbacks;



                // Pre-cache prism turret indices for O(n*p) instead of O(n�)
                const prismIndices = [];
                for (let j = 0; j < turretSystem.count; j++) {
                    if (turretSystem.items[j].type === TurretType.PRISM) prismIndices.push(j);
                }

                for (let i = 0; i < turretSystem.count; i++) {
                    const turret = turretSystem.get(i);
                    // Skip Prism (support only)
                    if (turret.type === TurretType.PRISM) continue;

                    // Prism Buffs Logic - only iterate cached prism indices
                    const prismBuffs = { damageMult: 1, rangeMult: 1, attackSpeedMult: 1, cooldownMult: 1 };
                    for (const j of prismIndices) {
                        const prismTurret = turretSystem.items[j];
                        const pRange = TURRET_STATS[TurretType.PRISM].range * 1.1;
                        const dx = prismTurret.x - turret.x;
                        const dy = prismTurret.y - turret.y;
                        if (dx * dx + dy * dy <= pRange * pRange) {
                            prismBuffs.damageMult += 0.3;
                        }
                    }

                    const stats = getTurretEffectiveStats(turret, state, prismBuffs);
                    this.ctx.stats = stats;

                    // Get behavior for this turret type (or default)
                    const behavior = TurretBehaviors[turret.type] || TurretBehaviors.DEFAULT;
                    if (behavior && behavior.onUpdate) {
                        behavior.onUpdate(turret, this.ctx);
                    }
                }
            }

            // Core weapon firing
            updateCoreWeapon(state, tree, dims, callbacks) {
                const {
                    spawnProjectile,
                    getDistanceSq,
                    metaState
                } = callbacks;

                const damageLevel = state.upgrades[UpgradeType.GLOBAL_DAMAGE] || 0;
                const rateLevel = state.upgrades[UpgradeType.GLOBAL_RATE] || 0;
                const rangeLevel = state.upgrades[UpgradeType.GLOBAL_RANGE] || 0;
                const metaDmgMult = 1 + ((metaState?.upgrades?.[MetaUpgradeType.TURRET_MASTERY] || 0) * 0.05);

                let coreCooldown = CORE_BASE_STATS.cooldown * (1 - (rateLevel * 0.05));
                let coreBaseDmg = CORE_BASE_STATS.damage;

                if (state.coreLevel >= 5) {
                    coreCooldown *= 0.5;
                    coreBaseDmg *= 2;
                }

                if (state.ultActiveTimer > 0 && state.selectedCoreWeapon === CoreWeaponType.BLASTER) {
                    coreCooldown *= 0.25;
                }

                if (state.gameTime - state.coreLastFired >= coreCooldown) {
                    const coreRange = CORE_BASE_STATS.range * (1 + (rangeLevel * 0.1));
                    const coreRangeSq = coreRange * coreRange;
                    const coreDamage = coreBaseDmg * (1 + (damageLevel * 0.1)) * metaDmgMult;

                    let targetIdx = -1;
                    let minDistSq = Infinity;
                    const corePos = { x: dims.w / 2, y: dims.h / 2 };

                    const candidateIndices = tree.searchIndices({
                        minX: corePos.x - coreRange,
                        minY: corePos.y - coreRange,
                        maxX: corePos.x + coreRange,
                        maxY: corePos.y + coreRange
                    }, enemySystem);

                    for (const idx of candidateIndices) {
                        if (enemySystem.hp[idx] <= 0) continue;
                        const ex = enemySystem.x[idx];
                        const ey = enemySystem.y[idx];
                        const dSq = (corePos.x - ex) ** 2 + (corePos.y - ey) ** 2;
                        if (dSq <= coreRangeSq && dSq < minDistSq) {
                            minDistSq = dSq;
                            targetIdx = idx;
                        }
                    }

                    if (targetIdx !== -1) {
                        const target = {
                            x: enemySystem.x[targetIdx],
                            y: enemySystem.y[targetIdx],
                            id: enemySystem.ids[targetIdx]
                        };
                        spawnProjectile(corePos, target, {
                            speed: 15,
                            color: '#ffffff',
                            shape: 'LINE',
                            damage: coreDamage,
                            turretId: 'CORE'
                        });
                        state.coreLastFired = state.gameTime;
                    }
                }
                state.coreLaserTarget = null;
            }


            placeTurret(type, x, y, state, callbacks) {
                const { spawnParticles, refs } = callbacks;
                let cost = Math.floor(TURRET_STATS[type].cost * (1 - (state.metaState?.upgrades?.[MetaUpgradeType.DISCOUNT_ENGINEERING] || 0) * 0.02));
                if (state.money < cost) return false;

                const cx = this.ctx.dims.w / 2, cy = this.ctx.dims.h / 2;
                if ((x - cx) ** 2 + (y - cy) ** 2 < (CORE_HOVER_RADIUS + GAME_CONSTANTS.TURRET_DEFAULT_RADIUS) ** 2) return false;

                const placeR = GAME_CONSTANTS.TURRET_DEFAULT_RADIUS;
                for (let i = 0; i < turretSystem.count; i++) {
                    const t = turretSystem.items[i];
                    const dx = t.x - x, dy = t.y - y;
                    if (dx * dx + dy * dy < (t.radius + placeR - 5) ** 2) return false;
                }

                state.money -= cost;
                turretSystem.spawn({
                    type,
                    x,
                    y,
                    cost,
                    level: 1,
                    killCount: 0,
                    lastFired: 0,
                    spawnTime: state.gameTime || 0,
                    hp: GAME_CONSTANTS.TURRET_DEFAULT_HP,
                    maxHp: GAME_CONSTANTS.TURRET_DEFAULT_HP,
                    range: TURRET_STATS[type].range,
                    damage: TURRET_STATS[type].damage,
                    cooldown: TURRET_STATS[type].cooldown,
                    color: TURRET_STATS[type].color,
                    radius: GAME_CONSTANTS.TURRET_DEFAULT_RADIUS,
                    targetingMode: TargetingMode.CLOSEST
                });

                useGameStore.setState(s => ({ turretVersion: s.turretVersion + 1, money: state.money }));
                refs.current.turretTreeDirty = true;
                spawnParticles(x, y, COLORS.WHITE, 5); spawnParticles(x, y, COLORS.WHITE, 5);
                return true;
            }

            sellTurret(index, state, callbacks) {
                const tData = turretSystem.get(index);
                useGameStore.setState(s => ({ money: s.money + Math.floor(tData.cost * SELL_REFUND_RATIO), turretVersion: s.turretVersion + 1 }));
                callbacks.spawnParticles(tData.x, tData.y, COLORS.GOLD, 10, 1.5);
                turretSystem.remove(index);
            }
        }

        const turretManager = new TurretManager();

        const EnemyBehaviors = {
            [EnemyType.SHOOTER]: (state, i, x, y, distToCoreSq, context) => {
                const range = ENEMY_STATS[EnemyType.SHOOTER].attackRange || 300;
                if (distToCoreSq > range * range) return false;
                // Shoot
                const angle = Math.atan2(context.dy, context.dx);
                context.enemySystem.vx[i] = 0; context.enemySystem.vy[i] = 0;
                if (state.gameTime - context.enemySystem.lastFired[i] >= (ENEMY_STATS[EnemyType.SHOOTER].attackCooldown || 2000)) {
                    context.enemySystem.lastFired[i] = state.gameTime;
                    state.enemyProjectiles.push({ id: Math.random().toString(), x, y, vx: Math.cos(angle) * 4, vy: Math.sin(angle) * 4, damage: 5, radius: 6, color: '#ff6b35' });
                }
                return true;
            },
            [EnemyType.DODGER]: (state, i, x, y, distToCoreSq, context) => {
                const { projectileSystem, enemySystem } = context;
                if (!projectileSystem) return false;
                let dodgeX = 0, dodgeY = 0, dodged = false;

                for (let p = 0; p < projectileSystem.count; p++) {
                    const proj = projectileSystem.items[p];
                    const pdx = x - proj.x, pdy = y - proj.y;
                    if (pdx * pdx + pdy * pdy < GAME_CONSTANTS.DODGER_DETECT_RADIUS_SQ) { dodgeX -= proj.vy; dodgeY += proj.vx; dodged = true; }
                }

                if (dodged) {
                    const len = Math.hypot(dodgeX, dodgeY);
                    if (len > 0) {
                        const speed = enemySystem.speed[i] * 1.5;
                        enemySystem.vx[i] = (dodgeX / len) * speed; enemySystem.vy[i] = (dodgeY / len) * speed;
                        enemySystem.x[i] += enemySystem.vx[i]; enemySystem.y[i] += enemySystem.vy[i];
                        return true;
                    }
                }
                return false;
            }
        };
        /** Manages enemy spawning, status effects, movement, and death */
        class EnemyManager {
            constructor() {
                this.ENEMY_COSTS = {
                    [EnemyType.BASIC]: 10,
                    [EnemyType.FAST]: 15,
                    [EnemyType.TANK]: 35,
                    [EnemyType.SPLITTER]: 25,
                };
            }

            update(state, dims, callbacks) {
                const {
                    spawnFloatingText,
                    spawnParticles,
                    setGameState,
                    setGameSpeed,
                    metaState,
                    dragRef
                } = callbacks;
                const centerX = dims.w / 2;
                const centerY = dims.h / 2;

                // Wave tracking (1 wave = 30 seconds for simplicity)
                const currentWave = Math.floor(state.gameTime / 30000) + 1;
                if (currentWave !== state.waveNumber) {
                    state.waveNumber = currentWave;

                    // Mutation trigger every 15 waves
                    if (currentWave > 0 && currentWave % 15 === 0 && currentWave !== state.lastMutationWave) {
                        state.lastMutationWave = currentWave;
                        const mutationTypes = Object.values(MutationType);
                        const available = mutationTypes.filter(m => !state.activeMutations.includes(m));
                        if (available.length > 0) {
                            const newMut = available[Math.floor(Math.random() * available.length)];
                            state.activeMutations.push(newMut);
                            const def = MUTATION_DEFS[newMut];
                            const color = def.isBuff ? '#10b981' : '#ef4444';
                            spawnFloatingText(dims.w / 2, 150, `MUTATION: ${def.name}`, color, 28);
                        }
                    }
                }

                // Difficulty scaling
                const difficultyTier = Math.floor(state.gameTime / 45000);
                state.difficultyRating = 1 + (difficultyTier * 0.2);

                // Scheduled spawns
                this.spawnBosses(state, dims, callbacks);
                this.spawnRegular(state, dims, difficultyTier);

                // Status effects (burn, poison, regen)
                this.applyStatusEffects(state, callbacks);

                // Movement and death
                this.moveAndProcessDeaths(state, centerX, centerY, callbacks);
            }

            spawnBosses(state, dims, callbacks) {
                const { spawnFloatingText } = callbacks;

                // Boss every 5 minutes
                if (state.gameTime >= 300000 && state.gameTime - state.lastBossSpawn >= 300000) {
                    state.lastBossSpawn = state.gameTime;
                    const ex = Math.random() > 0.5 ? 0 : dims.w;
                    const ey = Math.random() * dims.h;
                    const stats = ENEMY_STATS[EnemyType.BOSS];
                    const traitPool = [EnemyTrait.ARMORED, EnemyTrait.RESIST_SLOW, EnemyTrait.RESIST_STUN, EnemyTrait.REGEN];
                    const traits = [traitPool[Math.floor(Math.random() * 4)], traitPool[Math.floor(Math.random() * 4)]];
                    const hp = Math.round(200 * state.difficultyRating);

                    enemySystem.spawn({
                        id: Math.random().toString(), type: EnemyType.BOSS, x: ex, y: ey,
                        hp, maxHp: hp, speed: 0.5, reward: 200, radius: stats.radius, color: stats.color,
                        traits: [...new Set(traits)]
                    });

                    spawnFloatingText(dims.w / 2, 100, "?? BOSS INCOMING ??", "#ec4899", 32);
                }

                // Miniboss every 2.5 minutes
                if (state.gameTime >= 150000 && state.gameTime - state.lastMinibossSpawn >= 150000) {
                    state.lastMinibossSpawn = state.gameTime;
                    const ex = Math.random() > 0.5 ? 0 : dims.w;
                    const ey = Math.random() * dims.h;
                    const stats = ENEMY_STATS[EnemyType.MINIBOSS];
                    const traitPool = [EnemyTrait.ARMORED, EnemyTrait.RESIST_SLOW, EnemyTrait.RESIST_STUN, EnemyTrait.REGEN];
                    const traits = [traitPool[Math.floor(Math.random() * 4)]];
                    if (Math.random() < 0.3) traits.push(traitPool[Math.floor(Math.random() * 4)]);
                    const hp = Math.round(100 * state.difficultyRating);

                    enemySystem.spawn({
                        id: Math.random().toString(), type: EnemyType.MINIBOSS, x: ex, y: ey,
                        hp, maxHp: hp, speed: 1.2, reward: 75, radius: stats.radius, color: stats.color,
                        traits: [...new Set(traits)]
                    });

                    spawnFloatingText(dims.w / 2, 100, "MINIBOSS!", "#f43f5e", 24);
                }
            }

            spawnRegular(state, dims, difficultyTier) {
                if (state.gameTime >= state.nextSpawnTime) {
                    const spawnBudget = 50 + (difficultyTier * 20);

                    const unlockedTypes = [EnemyType.BASIC];
                    if (state.gameTime > 30000) unlockedTypes.push(EnemyType.FAST);
                    if (state.gameTime > 60000) unlockedTypes.push(EnemyType.SPLITTER);
                    if (state.gameTime > 90000) unlockedTypes.push(EnemyType.TANK);

                    let remainingBudget = spawnBudget;
                    const toSpawn = [];
                    while (remainingBudget > 0) {
                        const affordable = unlockedTypes.filter(t => this.ENEMY_COSTS[t] <= remainingBudget);
                        if (affordable.length === 0) break;
                        const type = affordable[Math.floor(Math.random() * affordable.length)];
                        toSpawn.push(type);
                        remainingBudget -= this.ENEMY_COSTS[type];
                    }

                    toSpawn.forEach((type, i) => {
                        setTimeout(() => {
                            let ex = 0, ey = 0;
                            if (Math.random() > 0.5) {
                                ex = Math.random() > 0.5 ? 0 : dims.w;
                                ey = Math.random() * dims.h;
                            } else {
                                ex = Math.random() * dims.w;
                                ey = Math.random() > 0.5 ? 0 : dims.h;
                            }

                            const stats = ENEMY_STATS[type];
                            const baseHp = { [EnemyType.BASIC]: 20, [EnemyType.FAST]: 15, [EnemyType.TANK]: 60, [EnemyType.SPLITTER]: 30 };

                            // Apply mutation multipliers (cached for efficiency)
                            let hpMult = 1, speedMult = 1;
                            const activeMuts = state.activeMutations || [];
                            for (const m of activeMuts) {
                                const def = MUTATION_DEFS[m];
                                if (def?.mult?.enemyHp) hpMult *= def.mult.enemyHp;
                                if (def?.mult?.enemySpeed) speedMult *= def.mult.enemySpeed;
                            }

                            const hp = Math.round((baseHp[type] || 20) * state.difficultyRating * hpMult);
                            const traits = [];
                            if (type === EnemyType.TANK && Math.random() < 0.3) traits.push(EnemyTrait.ARMORED);

                            // Apply mutation traits
                            if (activeMuts.includes(MutationType.ENEMY_REGEN)) traits.push(EnemyTrait.REGEN);
                            if (activeMuts.includes(MutationType.ARMORED_WAVE) && Math.random() < 0.5) traits.push(EnemyTrait.ARMORED);

                            enemySystem.spawn({
                                id: Math.random().toString(), type, x: ex, y: ey,
                                hp, maxHp: hp, speed: (2.5 / (stats.radius / 5)) * speedMult,
                                reward: { [EnemyType.BASIC]: 10, [EnemyType.FAST]: 12, [EnemyType.TANK]: 25, [EnemyType.SPLITTER]: 20 }[type] || 10,
                                radius: stats.radius, color: stats.color, traits
                            });
                        }, i * 200);
                    });

                    const delay = Math.max(3000, 5000 / state.difficultyRating);
                    state.nextSpawnTime = state.gameTime + delay;
                }
            }

            applyStatusEffects(state, callbacks) {
                const { spawnFloatingText } = callbacks;

                if (state.gameTime - state.lastRegenTime > 1000) {
                    let regenAmount = 0;
                    if (state.activeModules.includes(CoreModuleType.REPAIR_NANOBOTS)) regenAmount += 1;
                    if (regenAmount > 0) {
                        const maxH = INITIAL_HEALTH + ((state.upgrades[UpgradeType.MAX_HEALTH] || 0) * 50);
                        if (state.health < maxH) {
                            state.health = Math.min(maxH, state.health + regenAmount);
                        }
                    }

                    // Enemy status effects
                    for (let i = 0; i < enemySystem.count; i++) {
                        const traits = enemySystem.traits[i];

                        if (traits.includes(EnemyTrait.REGEN) && enemySystem.hp[i] < enemySystem.maxHp[i]) {
                            enemySystem.hp[i] += enemySystem.maxHp[i] * 0.01;
                        }

                        if (enemySystem.burn[i] > 0) {
                            enemySystem.hp[i] -= (enemySystem.maxHp[i] * 0.02) + 2;
                            enemySystem.burn[i] -= 60;
                        }

                        if (enemySystem.poison[i] > 0) {
                            enemySystem.hp[i] -= 5;
                            enemySystem.poison[i] -= 60;
                        }
                    }
                    state.lastRegenTime = state.gameTime;
                }
            }

            moveAndProcessDeaths(state, centerX, centerY, callbacks) {
                const {
                    spawnParticles,
                    setGameState,
                    setGameSpeed,
                    metaState,
                    dragRef,
                    getDistanceSq,
                    projectileSystem,
                    spawnFloatingText
                } = callbacks;

                for (let i = enemySystem.count - 1; i >= 0; i--) {
                    // Death handling
                    if (enemySystem.hp[i] <= 0) {
                        const upgrades = metaState?.upgrades || {};
                        const metaRewardMult = 1 + ((upgrades[MetaUpgradeType.SCRAP_RECYCLING] || 0) * 0.1);
                        const finalReward = Math.ceil(enemySystem.reward[i] * metaRewardMult);
                        state.money += finalReward;
                        state.score += enemySystem.reward[i] * 10;

                        if (state.coreLevel >= 5 && state.ultimateCharge < 100) {
                            state.ultimateCharge += 1;
                        }

                        const col = numToHex(enemySystem.color[i]);
                        spawnParticles(enemySystem.x[i], enemySystem.y[i], col, 4);

                        // Boss Death
                        if (enemySystem.type[i] === EnemyType.BOSS) {
                            spawnFloatingText(enemySystem.x[i], enemySystem.y[i], 'BOSS SLAIN!', '#ef4444', 28);
                        }
                        if (enemySystem.type[i] === EnemyType.MINIBOSS) {
                            spawnFloatingText(enemySystem.x[i], enemySystem.y[i], '+$75', '#fcd34d', 20);
                        }

                        // Splitter logic
                        if (enemySystem.type[i] === EnemyType.SPLITTER) {
                            const eX = enemySystem.x[i];
                            const eY = enemySystem.y[i];
                            const maxHp = enemySystem.maxHp[i];
                            const speed = enemySystem.speed[i];
                            const bitStats = ENEMY_STATS[EnemyType.SPLITTER_BIT];

                            for (let k = 0; k < 3; k++) {
                                enemySystem.spawn({
                                    id: Math.random().toString(),
                                    type: EnemyType.SPLITTER_BIT,
                                    x: eX + (Math.random() - 0.5) * 20,
                                    y: eY + (Math.random() - 0.5) * 20,
                                    hp: maxHp * 0.3,
                                    maxHp: maxHp * 0.3,
                                    speed: speed * 1.5,
                                    reward: 2,
                                    radius: bitStats.radius,
                                    color: bitStats.color,
                                    traits: []
                                });
                            }
                        }

                        enemySystem.remove(i);
                        continue;
                    }

                    // Movement & Logic
                    const id = enemySystem.ids[i];

                    // Dragging overrides behavior
                    if (dragRef.current.isDragging && dragRef.current.enemyId === id) {
                        enemySystem.x[i] = dragRef.current.currentX;
                        enemySystem.y[i] = dragRef.current.currentY;
                        enemySystem.vx[i] = 0;
                        enemySystem.vy[i] = 0;
                    } else {
                        const type = enemySystem.type[i];
                        const x = enemySystem.x[i];
                        const y = enemySystem.y[i];
                        let behavior = 'MOVE';

                        // Find closest target: core or any turret
                        let targetX = centerX;
                        let targetY = centerY;
                        let closestDistSq = (centerX - x) ** 2 + (centerY - y) ** 2;

                        // Check if any turret is closer than core
                        for (let ti = 0; ti < turretSystem.count; ti++) {
                            const turret = turretSystem.items[ti];
                            if (turret.hp <= 0) continue;
                            const tdx = turret.x - x;
                            const tdy = turret.y - y;
                            const tdSq = tdx * tdx + tdy * tdy;
                            if (tdSq < closestDistSq) {
                                closestDistSq = tdSq;
                                targetX = turret.x;
                                targetY = turret.y;
                            }
                        }

                        const dx = targetX - x;
                        const dy = targetY - y;
                        const distToCoreSq = (centerX - x) ** 2 + (centerY - y) ** 2;
                        const angle = Math.atan2(dy, dx);

                        // Apply Behaviors (Strategy Pattern)
                        let handled = false;
                        if (EnemyBehaviors[type]) {
                            handled = EnemyBehaviors[type](state, i, x, y, distToCoreSq, {
                                dx, dy, enemySystem, projectileSystem
                            });
                        }

                        if (!handled) {
                            // MOVE
                            let moveSpeed = enemySystem.speed[i];

                            // Status Effects
                            if (enemySystem.frozen[i] > 0) {
                                let slowFactor = 0.5;
                                const traits = enemySystem.traits[i];
                                if (traits.includes(EnemyTrait.RESIST_SLOW)) slowFactor = 0.8;
                                moveSpeed *= slowFactor;
                                enemySystem.frozen[i]--;
                            }
                            if (enemySystem.stunned[i] > 0) {
                                moveSpeed = 0;
                                enemySystem.stunned[i]--;
                            }

                            enemySystem.vx[i] = Math.cos(angle) * moveSpeed;
                            enemySystem.vy[i] = Math.sin(angle) * moveSpeed;
                            enemySystem.x[i] += enemySystem.vx[i];
                            enemySystem.y[i] += enemySystem.vy[i];
                        }
                    }

                    // Turret collision - enemies damage turrets they touch
                    const ex = enemySystem.x[i];
                    const ey = enemySystem.y[i];
                    const er = enemySystem.radius[i];
                    for (let t = turretSystem.count - 1; t >= 0; t--) {
                        const turret = turretSystem.items[t];
                        const tx = turret.x;
                        const ty = turret.y;
                        const tr = turret.radius || 20;
                        const distSq = (ex - tx) ** 2 + (ey - ty) ** 2;
                        const touchDist = er + tr;

                        if (distSq < touchDist * touchDist) {
                            const enemyDamage = GAME_CONSTANTS.ENEMY_DAMAGE_TO_TURRET;
                            turret.hp -= enemyDamage;

                            const dist = Math.sqrt(distSq);
                            if (dist > 0) {
                                const pushStrength = 2;
                                const dx = (ex - tx) / dist;
                                const dy = (ey - ty) / dist;
                                enemySystem.x[i] += dx * pushStrength;
                                enemySystem.y[i] += dy * pushStrength;
                            }

                            if (turret.hp <= 0) {
                                spawnParticles(tx, ty, COLORS.DESTROYED, 15, 1.5);
                                callbacks.spawnFloatingText(tx, ty, 'DESTROYED', COLORS.DESTROYED, 16);
                                turretSystem.remove(t);
                                state.turretVersion = (state.turretVersion || 0) + 1;
                            }
                        }
                    }

                    // Core collision
                    const distToCoreSq = (centerX - enemySystem.x[i]) ** 2 + (centerY - enemySystem.y[i]) ** 2;
                    if (distToCoreSq < 40 * 40) {
                        if (state.activeModules.includes(CoreModuleType.ICE_SHELL) && (state.moduleCooldowns[CoreModuleType.ICE_SHELL] || 0) <= 0) {
                            state.moduleCooldowns[CoreModuleType.ICE_SHELL] = CORE_MODULE_DEFS[CoreModuleType.ICE_SHELL].cooldown;
                            callbacks.spawnFloatingText(centerX, centerY, "SHIELD BLOCK", COLORS.SHIELD, 24);
                            spawnParticles(centerX, centerY, COLORS.SHIELD, 30, 3);

                            // Freeze nearby
                            for (let j = 0; j < enemySystem.count; j++) {
                                const dSq = (enemySystem.x[j] - centerX) ** 2 + (enemySystem.y[j] - centerY) ** 2;
                                if (dSq < 200 * 200) {
                                    enemySystem.frozen[j] = 120;
                                }
                            }

                            enemySystem.remove(i);
                            continue;
                        }

                        let drLevel = state.upgrades[UpgradeType.DAMAGE_REDUCTION];
                        let reductionPct = Math.min(0.5, drLevel * 0.05);
                        if (state.coreLevel >= 3) reductionPct += 0.2;

                        const damage = 10 * (1 - reductionPct);
                        state.health -= damage;

                        spawnParticles(enemySystem.x[i], enemySystem.y[i], COLORS.DAMAGE, 4);
                        enemySystem.remove(i);

                        if (state.health <= 0) {
                            setGameState(GameStatus.GAME_OVER);
                            setGameSpeed(0);
                            state.health = 0;
                        }
                    }
                }
            }
        }

        const enemyManager = new EnemyManager();

        /** Spatial grid for efficient proximity queries */
        class SpatialGrid {
            constructor(cellSize = GAME_CONSTANTS.GRID_CELL_SIZE) {
                this.cellSize = cellSize;
                this.cells = new Map();
            }
            clear() {
                this.cells.clear();
            }

            loadSystem(system) {
                const count = system.count;
                for (let i = 0; i < count; i++) {
                    const r = system.radius[i];
                    const minX = system.x[i] - r;
                    const minY = system.y[i] - r;
                    const maxX = system.x[i] + r;
                    const maxY = system.y[i] + r;

                    const startX = Math.floor(minX / this.cellSize);
                    const startY = Math.floor(minY / this.cellSize);
                    const endX = Math.floor(maxX / this.cellSize);
                    const endY = Math.floor(maxY / this.cellSize);

                    for (let x = startX; x <= endX; x++) {
                        for (let y = startY; y <= endY; y++) {
                            const key = (x * 73856093) ^ (y * 19349663);
                            let cell = this.cells.get(key);
                            if (!cell) { cell = []; this.cells.set(key, cell); }
                            cell.push(i);
                        }
                    }
                }
            }

            searchIndices(bbox, system) {
                const startX = Math.floor(bbox.minX / this.cellSize);
                const startY = Math.floor(bbox.minY / this.cellSize);
                const endX = Math.floor(bbox.maxX / this.cellSize);
                const endY = Math.floor(bbox.maxY / this.cellSize);

                const seen = new Set();
                const results = [];

                for (let x = startX; x <= endX; x++) {
                    for (let y = startY; y <= endY; y++) {
                        const key = (x * 73856093) ^ (y * 19349663);
                        const cell = this.cells.get(key);
                        if (cell) {
                            for (let i = 0; i < cell.length; i++) {
                                const idx = cell[i];
                                if (!seen.has(idx)) {
                                    seen.add(idx);
                                    const r = system.radius[idx];
                                    if (system.x[idx] + r >= bbox.minX &&
                                        system.x[idx] - r <= bbox.maxX &&
                                        system.y[idx] + r >= bbox.minY &&
                                        system.y[idx] - r <= bbox.maxY) {
                                        results.push(idx);
                                    }
                                }
                            }
                        }
                    }
                }
                return results;
            }
        }

        const updateEnemyProjectiles = (state, dims, callbacks) => {
            const cx = dims.w / 2, cy = dims.h / 2;
            for (let i = state.enemyProjectiles.length - 1; i >= 0; i--) {
                const p = state.enemyProjectiles[i];
                p.x += p.vx; p.y += p.vy;
                if ((p.x - cx) ** 2 + (p.y - cy) ** 2 <= (30 + p.radius) ** 2) {
                    state.health -= p.damage;
                    callbacks.spawnFloatingText(cx, cy - 30, `-${p.damage}`, '#ff6b35', 16);
                    callbacks.spawnParticles(p.x, p.y, p.color, 5);
                    state.enemyProjectiles.splice(i, 1);
                } else if (p.x < -50 || p.x > dims.w + 50 || p.y < -50 || p.y > dims.h + 50) {
                    state.enemyProjectiles.splice(i, 1);
                }
            }
        };

        // ==================== GAME LOOP & PHYSICS (RUNTIME) ====================
        /**
         * Custom hook to handle the 60FPS game loop and physics updates.
         * Separates the high-frequency game logic from the React component.
         */
        const useGameLoop = (refs, dims, callbacks) => {
            // Keep callbacks fresh without triggering re-effects
            const callbacksRef = useRef(callbacks);
            callbacksRef.current = callbacks;

            useEffect(() => {
                let animationFrameId;
                let lastTime = performance.now();

                /**
                 * Main physics update function (fixed timestep)
                 */
                const updatePhysics = () => {
                    const state = useGameStore.getState();
                    state.gameTime += FIXED_STEP;

                    const tree = refs.current.tree;
                    tree.clear();
                    tree.loadSystem(enemySystem);

                    const currentCallbacks = callbacksRef.current;
                    const managerCallbacks = {
                        ...currentCallbacks,
                        metaState: state.metaState,
                        getDistanceSq: Vec.distSq,
                        projectileSystem: refs.current.projectileSystem
                    };

                    enemyManager.update(state, dims.current, managerCallbacks);
                    turretManager.update(state, tree, dims.current, managerCallbacks);
                    turretManager.updateCoreWeapon(state, tree, dims.current, managerCallbacks);

                    // 2. Cooldowns & Timers
                    if (state.coreLevel >= 6) {
                        state.prismTimer += FIXED_STEP;
                        if (state.prismTimer > 5000) {
                            state.prismTimer = 0;
                            const cycle = ['FIRE', 'ICE', 'SHOCK', 'ACID'];
                            state.currentPrismElement = cycle[(cycle.indexOf(state.currentPrismElement) + 1) % cycle.length];
                            currentCallbacks.spawnFloatingText(dims.current.w / 2, dims.current.h / 2 - 60, `${state.currentPrismElement} PHASE`, '#fff', 24);
                        }
                    }
                    for (const k in state.moduleCooldowns) { if (state.moduleCooldowns[k] > 0) state.moduleCooldowns[k] -= FIXED_STEP; }
                    if (state.ultActiveTimer > 0) state.ultActiveTimer -= FIXED_STEP;

                    // Projectile Physics
                    const projSys = refs.current.projectileSystem;
                    projSys.update(enemySystem, tree, (p, target, idx) => currentCallbacks.handleProjectileHit(p, target, state, idx));
                    updateEnemyProjectiles(state, dims.current, currentCallbacks);

                    particleSystem.update();
                    lightningSystem.update();
                    expandingRingSystem.update();
                    for (let i = state.texts.length - 1; i >= 0; i--) {
                        const t = state.texts[i]; t.y += t.vy; t.life--;
                        if (t.life <= 0) state.texts.splice(i, 1);
                    }
                };

                const render = (time) => {
                    const realDt = Math.min(time - lastTime, 500);
                    lastTime = time;

                    const app = refs.current.app;
                    if (!app) {
                        animationFrameId = requestAnimationFrame(render);
                        return;
                    }

                    const state = useGameStore.getState();

                    if (state.gameState === GameStatus.PLAYING && state.gameSpeed > 0) { state.simAccumulator += realDt * state.gameSpeed; }

                    // Panic cap
                    if (state.simAccumulator > FIXED_STEP * 10) { state.simAccumulator = FIXED_STEP * 10; }

                    // Process physics
                    while (state.simAccumulator >= FIXED_STEP) {
                        updatePhysics();
                        state.simAccumulator -= FIXED_STEP;
                    }

                    // Sync game state to React UI
                    useGameStore.setState({
                        money: state.money,
                        health: state.health,
                        score: state.score,
                        gameTime: state.gameTime,
                        moduleCooldowns: { ...state.moduleCooldowns }
                    });

                    if (callbacksRef.current.updatePixiGraphics) { callbacksRef.current.updatePixiGraphics(state); }

                    animationFrameId = requestAnimationFrame(render);
                };

                animationFrameId = requestAnimationFrame(render);
                return () => cancelAnimationFrame(animationFrameId);
            }, []);
        };

        // ==================== MAIN GAME COMPONENT & CANVAS ====================
        const GameCanvas = () => {
            const canvasRef = useRef(null);
            const [screenSize, setScreenSize] = useState({ w: window.innerWidth, h: window.innerHeight });
            // PixiJS refs - Consolidated
            const refs = useRef({
                app: null,
                tree: new SpatialGrid(GAME_CONSTANTS.GRID_CELL_SIZE),  // Dynamic: enemies (rebuilt every frame)
                projectileSystem: projectileSystem,
                layers: null,
                containers: { core: null, particles: null },
                pools: {
                    enemies: [],
                    turrets: new Map(),
                    projectiles: [],
                    particles: [],
                    texts: [],
                    activeTexts: new Map()
                },
                textures: {
                    turrets: new Map(),
                    enemies: new Map(),
                    projectiles: new Map(),
                    core: new Map(),
                    coreGlow: new Map(),
                    particles: null,
                    glow: null,
                    pip: null,
                    preloaded: null
                },
                ui: {
                    placement: null,
                    tether: null,
                    hoverText: null,
                    coreGlow: null
                }
            });

            const dims = useRef({ w: window.innerWidth, h: window.innerHeight });

            // Subscribe to store for UI
            const shallowStr = (a, b) => { for (let k in a) if (a[k] !== b[k]) return false; return true; };
            const uiState = useGameStore(state => ({
                gameState: state.gameState,
                showUpgrades: state.showUpgrades,
                showTechLab: state.showTechLab,
                showCodex: state.showCodex,
                codexTab: state.codexTab,
                gameSpeed: state.gameSpeed,
                saveMessage: state.saveMessage,
                money: state.money,
                health: state.health,
                score: state.score,
                coreLevel: state.coreLevel,
                upgrades: state.upgrades,
                metaState: state.metaState,
                selectedCoreWeapon: state.selectedCoreWeapon,
                activeModules: state.activeModules,
                ultimateCharge: state.ultimateCharge,
                isPrismaticEnabled: state.isPrismaticEnabled,
                currentPrismElement: state.currentPrismElement,
                moduleCooldowns: state.moduleCooldowns,
                gameTime: state.gameTime,
                actions: {
                    setShowTechLab: state.setShowTechLab,
                    setShowCodex: state.setShowCodex,
                    setShowUpgrades: state.setShowUpgrades
                }
            }), (a, b) => Object.keys(a).length === Object.keys(b).length && shallowStr(a, b));

            const { actions: uiActions, ...uiStatsRaw } = uiState;
            const { setShowTechLab, setShowCodex, setShowUpgrades } = uiActions;


            const gameDuration = Math.floor(uiStatsRaw.gameTime / 1000);
            const uiStats = {
                ...uiStatsRaw,
                maxHealth: INITIAL_HEALTH + ((uiStatsRaw.upgrades[UpgradeType.MAX_HEALTH] || 0) * 50)
            };
            const {
                gameState,
                showUpgrades,
                showTechLab,
                showCodex,
                codexTab,
                gameSpeed,
                saveMessage,
                money,
                health,
                score,
                coreLevel,
                upgrades,
                metaState,
                selectedCoreWeapon,
                activeModules,
                ultimateCharge,
                isPrismaticEnabled,
                currentPrismElement,
                moduleCooldowns,
            } = uiStatsRaw;

            const {
                actions,
                setGameState,
                setGameSpeed,
                toggleUpgradeMenu,
                toggleTechLab,
                toggleCodex,
                setCodexTab,
                resetGame,
                setMousePos,
                setSelectedTurretType,
                setSelectedTurretId,
                setIsHoveringCanvas,
                setIsCoreSelected,
                selectedTurretType,
                selectedTurretId,
                isHoveringCanvas,
                mousePos,
                isCoreSelected
            } = useGameStore(s => ({
                actions: s.actions,
                setGameState: s.setGameState,
                setGameSpeed: s.setGameSpeed,
                toggleUpgradeMenu: s.toggleUpgradeMenu,
                toggleTechLab: s.toggleTechLab,
                toggleCodex: s.toggleCodex,
                setCodexTab: s.setCodexTab,
                resetGame: s.resetGame,
                setMousePos: s.setMousePos,
                setSelectedTurretType: s.setSelectedTurretType,
                setSelectedTurretId: s.setSelectedTurretId,
                setIsHoveringCanvas: s.setIsHoveringCanvas,
                setIsCoreSelected: s.setIsCoreSelected,
                selectedTurretType: s.selectedTurretType,
                selectedTurretId: s.selectedTurretId,
                isHoveringCanvas: s.isHoveringCanvas,
                mousePos: s.mousePos,
                isCoreSelected: s.isCoreSelected
            }), shallowStr);

            const dragRef = useRef({
                isDragging: false,
                enemyId: null,
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0
            });
            const [earnedTechPoints, setEarnedTechPoints] = useState(0);

            const selectedTurretData = useGameStore(s => {
                if (!s.selectedTurretId) return null;
                const idx = turretSystem.findById(s.selectedTurretId);
                return idx !== -1 ? turretSystem.getSnapshot(idx) : null;
            });
            const isNearCore = (point, radius = 50) => Vec.distSq(point, { x: dims.current.w / 2, y: dims.current.h / 2 }) < radius * radius;
            const getStartingMoney = () => INITIAL_MONEY + (metaState.upgrades[MetaUpgradeType.STARTING_CASH] * 50);
            const getBaseMaxHealth = () => INITIAL_HEALTH + (metaState.upgrades[MetaUpgradeType.CORE_SHIELDING] * 25);
            const getMaxHealth = useCallback(() => getBaseMaxHealth() + (upgrades[UpgradeType.MAX_HEALTH] * 25), [upgrades, metaState]);
            // @spawn-particles
            const spawnParticles = (
                x,
                y,
                color,
                count,
                speed = 1,
                size = 1
            ) => particleSystem.spawn(x, y, color, count, speed, size);
            const spawnDirectional = (
                x,
                y,
                color,
                count,
                angle,
                spread,
                speed = 1,
                size = 1
            ) => particleSystem.spawnDirectional(x, y, color, count, angle, spread, speed, size);
            const spawnSingleParticle = (
                x,
                y,
                vx,
                vy,
                life,
                colorHex,
                size
            ) => particleSystem.spawnSingle(x, y, vx, vy, life, colorHex, size);
            const spawnFloatingText = (
                x,
                y,
                text,
                color,
                size = 14
            ) => useGameStore.getState().texts.push({
                id: Math.random().toString(),
                x,
                y: y - 10,
                text,
                color,
                size,
                vy: -0.5 - Math.random() * 0.5,
                life: 40
            });

            // Keyboard handler for ultimate (X key)
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.key === 'x' || e.key === 'X') {
                        const state = useGameStore.getState();
                        if (state.coreLevel >= 5 && state.ultimateCharge >= 100 && state.gameState === GameStatus.PLAYING) {
                            // Trigger ultimate - function defined below
                            window.dispatchEvent(new CustomEvent('activateUltimate'));
                        }
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, []);

            const applyStatusEffect = (target, effect) => {
                if (!target || !effect) return;
                const { type, duration } = effect;
                switch (type) {
                    case 'FIRE': target.burn = duration; break;
                    case 'ICE': target.frozen = duration; break;
                    case 'SHOCK':
                        if (!(target.traits || []).includes(EnemyTrait.RESIST_STUN)) target.stunned = duration;
                        break;
                    case 'ACID': target.poison = duration; break;
                }
            };
            // All damage goes through this function for consistent armor/resistance handling
            const damageEntity = (target, packet) => {
                if (!target || target.hp <= 0) return 0;
                const {
                    amount = 0,
                    source = null,          // turret object, 'CORE', or null
                    statusEffect = null,
                    isCrit = false,
                    color = '#ffffff',
                    showFloatingText = true
                } = packet;

                let finalDamage = amount;
                if ((target.traits || []).includes(EnemyTrait.ARMORED)) { finalDamage *= GAME_CONSTANTS.ARMOR_REDUCTION; }
                target.hp -= finalDamage;
                applyStatusEffect(target, statusEffect);

                if (showFloatingText && finalDamage > 0) { spawnFloatingText(target.x, target.y, Math.floor(finalDamage).toString(), color, isCrit ? 18 : 14); }
                if (isCrit) spawnParticles(target.x, target.y, '#ffffff', 6, 1.5);
                if (target.hp <= 0 && source) { if (typeof source === 'object' && source.killCount !== undefined) { source.killCount++; } }

                return finalDamage;
            };

            const handleProjectileHit = (p, target, state, enemyIdx) => {
                if (typeof enemyIdx === 'number' && enemyIdx >= 0 && enemyIdx < enemySystem.count) {
                    const turretIdx = p.turretId && p.turretId !== 'CORE'
                        ? turretSystem.findById(p.turretId)
                        : -1;

                    let finalDamage = p.damage || 0;
                    const traits = enemySystem.traits[enemyIdx] || [];
                    if (traits.includes(EnemyTrait.ARMORED)) { finalDamage *= GAME_CONSTANTS.ARMOR_REDUCTION; }

                    const oldHp = enemySystem.hp[enemyIdx];
                    enemySystem.hp[enemyIdx] -= finalDamage;

                    if (finalDamage > 0 && oldHp > enemySystem.hp[enemyIdx]) {
                        spawnFloatingText(target.x, target.y, Math.floor(finalDamage).toString(), p.color || '#ffffff', p.isCrit ? 18 : 14);
                    }
                    if (p.isCrit) spawnParticles(target.x, target.y, '#ffffff', 6, 1.5);

                    if (p.statusEffect) {
                        const { type, duration } = p.statusEffect;
                        switch (type) {
                            case 'FIRE': enemySystem.burn[enemyIdx] = duration; break;
                            case 'ICE': enemySystem.frozen[enemyIdx] = duration; break;
                            case 'SHOCK':
                                if (!traits.includes(EnemyTrait.RESIST_STUN)) enemySystem.stunned[enemyIdx] = duration;
                                break;
                            case 'ACID':
                                enemySystem.poison[enemyIdx] = duration;
                                // Acid burst particle effect
                                spawnParticles(target.x, target.y, p.color || '#84cc16', 10, 1.0, 1.5);
                                break;
                        }
                    }

                    if (enemySystem.hp[enemyIdx] <= 0 && turretIdx !== -1) {
                        turretSystem.items[turretIdx].killCount++;
                    }
                }
            };
            const dealInstantDamage = (target, damage, options = {}) => {
                damageEntity(target, {
                    amount: damage,
                    source: options.source || null,
                    statusEffect: options.statusEffect,
                    isCrit: options.isCrit,
                    color: options.color || '#ffffff'
                });
                spawnParticles(target.x, target.y, options.color || '#ffffff', 5);
            };

            // Lead prediction: calculates intercept point where projectile and enemy will meet
            const getInterceptPoint = (source, target, speed) => {
                if (!target || !target.vx && !target.vy) return { x: target.x, y: target.y };
                const dx = target.x - source.x, dy = target.y - source.y;
                const tvx = target.vx || 0, tvy = target.vy || 0;
                const a = tvx * tvx + tvy * tvy - speed * speed;
                const b = 2 * (dx * tvx + dy * tvy);
                const c = dx * dx + dy * dy;
                if (Math.abs(a) < 0.001) { const t = -c / b; return t > 0 ? { x: target.x + tvx * t, y: target.y + tvy * t } : { x: target.x, y: target.y }; }
                const d = b * b - 4 * a * c;
                if (d < 0) return { x: target.x, y: target.y };
                const t1 = (-b - Math.sqrt(d)) / (2 * a), t2 = (-b + Math.sqrt(d)) / (2 * a);
                const t = (t1 > 0 && t2 > 0) ? Math.min(t1, t2) : (t1 > 0 ? t1 : (t2 > 0 ? t2 : -1));
                if (t < 0 || t > 5) return { x: target.x, y: target.y };
                return { x: target.x + tvx * t, y: target.y + tvy * t };
            };

            const checkPlacementValidity = (x, y, cost) => {
                const s = useGameStore.getState();
                return s.money >= cost && !isNearCore({ x, y }, 60) && !s.turrets.some(t => Vec.distSq(t, { x, y }) < 900);
            };

            // @spawn-projectile
            const spawnProjectile = (source, target, stats, angleOffset = 0) => {
                let angle = angleOffset, tx = 0, ty = 0;
                if (target) {
                    const i = getInterceptPoint(source, target, stats.speed);
                    angle += Math.atan2(i.y - source.y, i.x - source.x);
                    tx = i.x; ty = i.y;
                }
                projectileSystem.spawn({
                    x: source.x, y: source.y, vx: Math.cos(angle) * stats.speed, vy: Math.sin(angle) * stats.speed,
                    angle, speed: stats.speed, color: stats.color, life: stats.isMissile ? 300 : 120,
                    radius: stats.isMissile ? 6 : (stats.isCrit ? 4 : 3), isMissile: stats.isMissile, shape: stats.shape,
                    cosmetic: false, targetId: null, targetX: tx, targetY: ty,
                    damage: stats.damage || 0, statusEffect: stats.statusEffect || null, turretId: stats.turretId, isCrit: stats.isCrit
                });
            };

            const spawnRailgunBeam = (x1, y1, x2, y2, color, width) => {
                const dx = x2 - x1, dy = y2 - y1, dist = Math.sqrt(dx * dx + dy * dy), angle = Math.atan2(dy, dx), segments = Math.floor(dist / 10);
                for (let i = 0; i < segments; i++) particleSystem.spawnSingle(x1 + Math.cos(angle) * (i * 10), y1 + Math.sin(angle) * (i * 10), (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5, 20, color, width);
            };

            const spawnLightning = (x1, y1, x2, y2, color, width = 2) => {
                const hexColor = typeof color === 'string' ? RenderSystem.hexToNum(color) : color;
                lightningSystem.add(x1, y1, x2, y2, hexColor, width);
                // Impact sparks
                particleSystem.spawnSingle(x2, y2, (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5, 12, '#ffffff', width * 2);
            };

            const getPrismBuff = (turret, allTurrets) => {
                const state = useGameStore.getState();
                if (!state.isPrismaticEnabled || state.coreLevel < 6) return null;
                // Simple version: check if any PRISM turret is nearby
                const buffer = allTurrets.find(t => t.type === TurretType.PRISM && Vec.distSq(t, turret) < 150 * 150);
                if (buffer) return { element: state.currentPrismElement };
                return null;
            };

            // @turret-effective-stats — Calculates final damage/range/cooldown with upgrades, prism, meta
            const getTurretEffectiveStats = (turret, state, prismBuffs, gameTime = 0) => {
                const stats = TURRET_STATS[turret.type];

                const metaState = state.metaState || useGameStore.getState().metaState;
                const metaDmgMult = 1 + ((metaState?.upgrades?.[MetaUpgradeType.TURRET_MASTERY] || 0) * 0.05);

                let damage = stats.damage * (1 + (state.upgrades[UpgradeType.GLOBAL_DAMAGE] || 0) * 0.1);
                let range = stats.range * (1 + (state.upgrades[UpgradeType.GLOBAL_RANGE] || 0) * 0.1);
                let cooldown = stats.cooldown * (1 - (state.upgrades[UpgradeType.GLOBAL_RATE] || 0) * 0.05);

                damage *= metaDmgMult;



                if (prismBuffs) damage *= 1.2; // 20% damage boost from prism

                return {
                    effectiveDamage: damage,
                    effectiveRange: range,
                    effectiveCooldown: Math.max(50, cooldown),
                    effectiveRangeSq: range * range
                };
            };

            // @save-game
            const saveGame = () => {
                useGameStore.setState({ saveMessage: "GAME SAVED" });
                setTimeout(() => useGameStore.setState({ saveMessage: null }), 2000);
            };

            // @load-game
            const loadGame = () => {
                const saved = localStorage.getItem(SAVE_SLOT_KEY);
                if (!saved) {
                    useGameStore.setState({ saveMessage: "NO SAVE FOUND" });
                    setTimeout(() => useGameStore.setState({ saveMessage: null }), 2000);
                    return;
                }
                const data = JSON.parse(saved);
                useGameStore.setState({
                    ...data,
                    enemies: [], texts: [],
                    // projectiles/particles managed externally
                    gameState: GameStatus.IDLE,
                    saveMessage: "GAME LOADED"
                });
                setTimeout(() => useGameStore.setState({ saveMessage: null }), 2000);
            };

            const startGame = useCallback(() => resetGame(), [resetGame]);

            const activateUltimate = useCallback(() => {
                const state = useGameStore.getState();
                if (state.ultimateCharge >= 100) {
                    state.ultimateCharge = 0;
                    state.ultActiveTimer = 300;

                    spawnFloatingText(dims.current.w / 2, dims.current.h / 2, "ULTIMATE READY", '#f43f5e', 32);
                    spawnParticles(dims.current.w / 2, dims.current.h / 2, '#f43f5e', 50, 4);

                    switch (state.selectedCoreWeapon) {
                        case CoreWeaponType.SWARM:
                            for (let k = 0; k < 40; k++) {
                                const ang = (Math.PI * 2 * k) / 40;
                                // ang is already defined above
                                projectileSystem.spawn({
                                    x: dims.current.w / 2,
                                    y: dims.current.h / 2,
                                    vx: Math.cos(ang) * 10,
                                    vy: Math.sin(ang) * 10,
                                    angle: ang,
                                    speed: 10,
                                    color: '#f43f5e',
                                    life: 300,
                                    radius: 4,
                                    isMissile: true,
                                    shape: 'ROCKET',
                                    damage: 25,
                                    targetId: null,
                                    cosmetic: false
                                });
                            }
                            break;
                        case CoreWeaponType.LASER:
                            state.enemies.forEach(e => {
                                e.hp -= 200;
                                spawnParticles(e.x, e.y, '#22d3ee', 10);
                            });
                            spawnParticles(dims.current.w / 2, dims.current.h / 2, '#22d3ee', 100, 10);
                            break;
                    }
                }
            }, []);

            // Listen for X key event to activate ultimate
            useEffect(() => {
                const handler = () => activateUltimate();
                window.addEventListener('activateUltimate', handler);
                return () => window.removeEventListener('activateUltimate', handler);
            }, [activateUltimate]);

            const calculatePrestige = () => Math.floor(useGameStore.getState().score / 200);

            useEffect(() => {
                if (gameState === GameStatus.GAME_OVER) {
                    const points = calculatePrestige();
                    setEarnedTechPoints(points);
                    actions.updateMeta(prev => ({ techPoints: prev.techPoints + points }));
                }
            }, [gameState]);

            // PixiJS Initialization
            useEffect(() => {
                if (!canvasRef.current || refs.current.app) return;

                // PixiJS v8 async initialization
                (async () => {
                    const app = new PIXI.Application();
                    await app.init({
                        width: dims.current.w,
                        height: dims.current.h,
                        backgroundColor: 0x050505,
                        canvas: canvasRef.current,
                        antialias: true,
                        resolution: window.devicePixelRatio || 1,
                        autoDensity: true
                    });
                    refs.current.app = app;

                    // Preload all textures upfront
                    refs.current.textures.preloaded = await preloadAssets(app);

                    // Create layers (order = z-index)
                    const layerNames = ['grid', 'noBuild', 'turrets', 'enemies', 'projectiles', 'particles', 'texts', 'core', 'ui'];
                    const layers = {};
                    layerNames.forEach(name => {
                        layers[name] = new PIXI.Container();
                        app.stage.addChild(layers[name]);
                    });
                    refs.current.layers = layers;

                    const grid = new PIXI.Graphics();
                    grid.setStrokeStyle({ width: 1, color: 0x0f172a });
                    for (let x = 0; x <= dims.current.w; x += 50) { grid.moveTo(x, 0); grid.lineTo(x, dims.current.h); }
                    for (let y = 0; y <= dims.current.h; y += 50) { grid.moveTo(0, y); grid.lineTo(dims.current.w, y); }
                    grid.stroke();
                    layers.grid.addChild(grid);

                    const coreContainer = new PIXI.Container();
                    const glowSize = 120, glowCanvas = document.createElement('canvas');
                    glowCanvas.width = glowCanvas.height = glowSize;
                    const glowSprite = new PIXI.Sprite(PIXI.Texture.WHITE);
                    glowSprite.label = 'glow'; glowSprite.anchor.set(0.5); glowSprite.width = glowSprite.height = glowSize;
                    coreContainer.addChild(glowSprite);
                    refs.current.ui.coreGlow = { sprite: glowSprite, canvas: glowCanvas, ctx: glowCanvas.getContext('2d'), size: glowSize };
                    ['aura', 'healthBg', 'healthFill', 'cryoShield', 'selection'].forEach(label => {
                        const g = new PIXI.Graphics(); g.label = label; coreContainer.addChild(g);
                    });
                    layers.core.addChild(coreContainer);
                    refs.current.containers.core = coreContainer;

                    // Create particle texture and container
                    const pGfx = new PIXI.Graphics(); pGfx.circle(8, 8, 8).fill(0xffffff);
                    refs.current.textures.particles = app.renderer.generateTexture(pGfx);

                    // Pixi v8 automatically batches sprites. ParticleContainer is deprecated/changed.
                    const particleContainer = new PIXI.Container();
                    layers.particles.addChild(particleContainer);
                    refs.current.containers.particles = particleContainer;

                    const projGlowSize = 128;
                    const projGlowCanvas = document.createElement('canvas');
                    projGlowCanvas.width = projGlowCanvas.height = projGlowSize;
                    const projGlowCtx = projGlowCanvas.getContext('2d');
                    const projGradient = projGlowCtx.createRadialGradient(projGlowSize / 2, projGlowSize / 2, 0, projGlowSize / 2, projGlowSize / 2, projGlowSize / 2);
                    projGradient.addColorStop(0, 'rgba(255,255,255,0.9)');
                    projGradient.addColorStop(0.1, 'rgba(255,255,255,0.8)');
                    projGradient.addColorStop(0.3, 'rgba(255,255,255,0.4)');
                    projGradient.addColorStop(0.6, 'rgba(255,255,255,0.1)');
                    projGradient.addColorStop(1, 'rgba(255,255,255,0)');
                    projGlowCtx.fillStyle = projGradient;
                    projGlowCtx.beginPath();
                    projGlowCtx.arc(projGlowSize / 2, projGlowSize / 2, projGlowSize / 2, 0, Math.PI * 2);
                    projGlowCtx.fill();
                    refs.current.textures.glow = PIXI.Texture.from(projGlowCanvas);

                    const preview = new PIXI.Graphics(); preview.visible = false;
                    layers.ui.addChild(preview); refs.current.ui.placement = preview;
                    const noBuild = new PIXI.Graphics(); noBuild.visible = false;
                    layers.noBuild.addChild(noBuild); refs.current.ui.noBuild = noBuild;
                    const tether = new PIXI.Graphics(); tether.visible = false;
                    layers.ui.addChild(tether); refs.current.ui.tether = tether;
                    const hoverText = new PIXI.Text({ text: 'ACCESS SYSTEM', style: { fontFamily: 'monospace', fontSize: 10, fontWeight: 'bold', fill: 0xffffff } });
                    hoverText.anchor.set(0.5); hoverText.visible = false;
                    layers.ui.addChild(hoverText); refs.current.ui.hoverText = hoverText;
                })();

                return () => {
                    if (refs.current.app) {
                        refs.current.app.destroy(true, { children: true, texture: true });
                        refs.current.app = null;
                    }
                };
            }, []);
            // Handles window resize: updates dimensions, resizes renderer, redraws grid
            useEffect(() => {
                const handleResize = () => {
                    const oldW = dims.current.w;
                    const oldH = dims.current.h;
                    const newW = window.innerWidth;
                    const newH = window.innerHeight;

                    if (oldW === newW && oldH === newH) return;

                    setScreenSize({ w: newW, h: newH });
                    dims.current = { w: newW, h: newH };

                    // Calculate center shift
                    const dx = (newW - oldW) / 2;
                    const dy = (newH - oldH) / 2;

                    // Shift all game entities to stay centered
                    const state = useGameStore.getState();

                    // Shift turrets
                    for (const t of turretSystem.items) {
                        t.x += dx;
                        t.y += dy;
                    }
                    for (let i = 0; i < enemySystem.count; i++) {
                        enemySystem.x[i] += dx;
                        enemySystem.y[i] += dy;
                    }
                    // Shift projectiles
                    for (const p of projectileSystem.items) {
                        p.x += dx;
                        p.y += dy;
                    }
                    for (let i = 0; i < particleSystem.count; i++) {
                        particleSystem.x[i] += dx;
                        particleSystem.y[i] += dy;
                    }
                    state.texts.forEach(t => { t.x += dx; t.y += dy; });

                    // Shift drag state if active
                    if (dragRef.current.isDragging) {
                        dragRef.current.startX += dx;
                        dragRef.current.startY += dy;
                        dragRef.current.currentX += dx;
                        dragRef.current.currentY += dy;
                    }

                    const app = refs.current.app;
                    if (!app) return;

                    // Resize PixiJS renderer
                    app.renderer.resize(newW, newH);

                    // Redraw grid to match new size
                    const layers = refs.current.layers;
                    if (layers && layers.grid) {
                        layers.grid.removeChildren();
                        const grid = new PIXI.Graphics();
                        grid.setStrokeStyle({ width: 1, color: 0x0f172a });
                        for (let x = 0; x <= newW; x += 50) { grid.moveTo(x, 0); grid.lineTo(x, newH); }
                        for (let y = 0; y <= newH; y += 50) { grid.moveTo(0, y); grid.lineTo(newW, y); }
                        grid.stroke();
                        layers.grid.addChild(grid);
                    }
                };
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);
            useEffect(() => {
                const handleKeydown = (e) => {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        // Toggle gameSpeed: 0 = paused, 1 = playing
                        const currentSpeed = useGameStore.getState().gameSpeed;
                        setGameSpeed(currentSpeed === 0 ? 1 : 0);
                    }
                };
                window.addEventListener('keydown', handleKeydown);
                return () => window.removeEventListener('keydown', handleKeydown);
            }, []);

            /**
             * Main render loop - updates all PixiJS graphics each frame
             */
            const updatePixiGraphics = (state) => {
                if (!refs.current.app || !refs.current.layers) return;
                const cx = dims.current.w / 2, cy = dims.current.h / 2;
                updateCoreVisuals(state, cx, cy); // Includes core hover text
                updateTurretGraphics(state, cx, cy);
                updateEnemyGraphics(state);
                updateProjectileGraphics(state);
                updateParticleGraphics(state);
                updateLightningGraphics();
                updateRingGraphics();
                updateFloatingTextGraphics(state);
                updateInteractionOverlays(state); // Unified: placement preview, no-build zones, selected range, drag tether
            };

            /** Unified interaction overlays: placement preview, no-build zones, selected turret range, drag tether */
            const updateInteractionOverlays = (state) => {
                const rangeGfx = refs.current.ui.placement;
                const noBuildGfx = refs.current.ui.noBuild;
                const tetherGfx = refs.current.ui.tether;

                if (rangeGfx) rangeGfx.clear();
                if (noBuildGfx) noBuildGfx.clear();
                if (tetherGfx) tetherGfx.clear();

                const { selectedTurretType: turretType, isHoveringCanvas: hovering, mousePos: mpos, selectedTurretId } = useGameStore.getState();

                // Priority 1: Placement preview
                if (turretType && hovering && rangeGfx) {
                    const mx = mpos.x, my = mpos.y;
                    const cx = dims.current.w / 2, cy = dims.current.h / 2;
                    let cost = TURRET_STATS[turretType].cost;
                    const discountLvl = state.metaState?.upgrades?.[MetaUpgradeType.DISCOUNT_ENGINEERING] || 0;
                    cost = Math.floor(cost * (1 - (discountLvl * 0.02)));

                    let isValid = state.money >= cost;
                    const placeR = GAME_CONSTANTS.TURRET_DEFAULT_RADIUS;
                    // Check core distance
                    if ((mx - cx) ** 2 + (my - cy) ** 2 < (CORE_HOVER_RADIUS + placeR) ** 2) isValid = false;
                    // Check overlap
                    if (isValid) {
                        for (let i = 0; i < turretSystem.count; i++) {
                            const t = turretSystem.items[i];
                            const dx = t.x - mx;
                            const dy = t.y - my;
                            if (dx * dx + dy * dy < (t.radius + placeR - 5) ** 2) { isValid = false; break; }
                        }
                    }

                    const rangeLevel = state.upgrades[UpgradeType.GLOBAL_RANGE] || 0;
                    let effectiveRange = TURRET_STATS[turretType].range * (1 + (rangeLevel * 0.1));
                    if (state.coreLevel >= 4 && isNearCore({ x: mx, y: my }, 250)) effectiveRange *= 1.2;
                    const color = isValid ? RenderSystem.hexToNum(TURRET_STATS[turretType].color) : 0xef4444;

                    rangeGfx.visible = true;
                    rangeGfx.circle(mx, my, effectiveRange).fill({ color, alpha: 0.15 });
                    rangeGfx.circle(mx, my, effectiveRange).stroke({ width: 2, color, alpha: 0.7 });
                    rangeGfx.circle(mx, my, 8).fill({ color, alpha: 0.9 });

                    if (noBuildGfx) {
                        noBuildGfx.visible = true;
                        noBuildGfx.circle(cx, cy, 60).fill({ color: 0xef4444, alpha: 0.1 });
                        noBuildGfx.circle(cx, cy, 60).stroke({ width: 2, color: 0xef4444, alpha: 0.6 });
                        for (let i = 0; i < turretSystem.count; i++) { const t = turretSystem.items[i]; noBuildGfx.circle(t.x, t.y, 30).stroke({ width: 1, color: 0xef4444, alpha: 0.4 }); }
                    }
                    return;
                }
                if (noBuildGfx) noBuildGfx.visible = false;

                // Priority 2: Selected turret range (only for non-area turrets, since area turrets show range permanently)
                if (selectedTurretId && rangeGfx) {
                    const idx = turretSystem.findById(selectedTurretId);
                    if (idx !== -1) {
                        const turret = turretSystem.get(idx);
                        // Area turrets (cryo, flamethrower, shockwave, tesla) already show their range permanently
                        // Only draw selection range for other turret types
                        if (!isAreaTurret(turret.type)) {
                            const effectiveStats = getTurretEffectiveStats(turret, state, null, state.gameTime);
                            const range = effectiveStats.effectiveRange;
                            rangeGfx.visible = true;
                            rangeGfx.circle(turret.x, turret.y, range).fill({ color: turret.color, alpha: 0.15 });
                            rangeGfx.circle(turret.x, turret.y, range).stroke({ width: 2, color: turret.color, alpha: 0.7 });
                        } else { rangeGfx.visible = false; }
                    }
                } else if (rangeGfx) { rangeGfx.visible = false; }


                // Priority 3: Tether
                if (tetherGfx) {
                    if (dragRef.current.isDragging && dragRef.current.enemyId) {
                        tetherGfx.visible = true;
                        const dx = dragRef.current.currentX - dragRef.current.startX;
                        const dy = dragRef.current.currentY - dragRef.current.startY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const segments = Math.floor(dist / 10);
                        for (let i = 0; i < segments; i += 2) {
                            const t1 = i / segments;
                            const t2 = Math.min((i + 1) / segments, 1);
                            tetherGfx.moveTo(dragRef.current.startX + dx * t1, dragRef.current.startY + dy * t1);
                            tetherGfx.lineTo(dragRef.current.startX + dx * t2, dragRef.current.startY + dy * t2);
                        }
                        tetherGfx.stroke({ width: 2, color: 0x22d3ee });
                        const maxDrag = BASE_DRAG_RADIUS + (state.coreLevel * DRAG_RADIUS_PER_LEVEL);
                        tetherGfx.circle(dragRef.current.startX, dragRef.current.startY, maxDrag);
                        tetherGfx.stroke({ width: 1, color: 0x22d3ee, alpha: 0.2 });
                        tetherGfx.circle(dragRef.current.startX, dragRef.current.startY, 5);
                        tetherGfx.fill(0x22d3ee);
                    } else { tetherGfx.visible = false; }
                }
            };

            /** Renders the central core: glow, aura, health bar, cryo shield, selection ring */
            const updateCoreVisuals = (state, cx, cy) => {
                const c = refs.current.containers.core; if (!c) return;
                const low = state.health <= 20, colorHex = low ? '#ef4444' : '#0ea5e9', color = low ? 0xef4444 : 0x0ea5e9;

                // Glow sprite with cached texture by color
                const g = refs.current.ui.coreGlow;
                if (g && g.sprite) {
                    const glowTexture = RenderSystem.getCoreGlowTexture(colorHex, refs.current.textures);
                    if (glowTexture && g.sprite.texture !== glowTexture) { g.sprite.texture = glowTexture; }
                    g.sprite.x = cx; g.sprite.y = cy;
                }

                const aura = c.getChildByLabel('aura'); aura.clear();
                if (state.coreLevel >= 2) { aura.circle(cx, cy, 250).fill({ color: 0x0ea5e9, alpha: 0.03 }); aura.circle(cx, cy, 250).stroke({ width: 1, color: 0x0ea5e9, alpha: 0.1 }); }

                // Core circle - use cached sprite
                let coreSprite = c.getChildByLabel('coreSprite');
                if (!coreSprite) {
                    coreSprite = new PIXI.Sprite();
                    coreSprite.label = 'coreSprite';
                    coreSprite.anchor.set(0.5);
                    c.addChild(coreSprite);
                }
                const coreTexture = RenderSystem.getCoreTexture(colorHex, refs.current.textures, refs.current.app);
                if (coreTexture && coreSprite.texture !== coreTexture) { coreSprite.texture = coreTexture; }
                coreSprite.x = cx; coreSprite.y = cy;

                const maxH = INITIAL_HEALTH + ((state.upgrades[UpgradeType.MAX_HEALTH] || 0) * 50);
                const hpPct = Math.max(0, state.health / maxH);
                const hBg = c.getChildByLabel('healthBg'); hBg.clear(); hBg.rect(cx - 40, cy + 40, 80, 8).fill(0x334155);
                const hFill = c.getChildByLabel('healthFill'); hFill.clear(); hFill.rect(cx - 40, cy + 40, 80 * hpPct, 8).fill(hpPct > 0.5 ? 0x22c55e : 0xef4444);

                const cryo = c.getChildByLabel('cryoShield'); cryo.clear();
                if (state.activeModules.includes(CoreModuleType.ICE_SHELL) && (state.moduleCooldowns[CoreModuleType.ICE_SHELL] || 0) <= 0) { cryo.arc(cx, cy, 45, state.gameTime * 0.001, state.gameTime * 0.001 + Math.PI * 1.5).stroke({ width: 2, color: 0xb0e0e6 }); }

                const sel = c.getChildByLabel('selection'); sel.clear();
                if (isCoreSelected) { sel.circle(cx, cy, 50).stroke({ width: 2, color: 0x0ea5e9 }); }

                // Draw laser beam to target
                let laserGfx = c.getChildByLabel('coreLaser');
                if (!laserGfx) {
                    laserGfx = new PIXI.Graphics();
                    laserGfx.label = 'coreLaser';
                    c.addChild(laserGfx);
                }
                laserGfx.clear();
                if (state.coreLaserTarget) {
                    const tx = state.coreLaserTarget.x;
                    const ty = state.coreLaserTarget.y;

                    // Pulse effect using sine wave
                    const pulse = Math.sin(state.gameTime * 0.02) * 0.5 + 0.5; // 0 to 1
                    const outerWidth = 4 + pulse * 6; // 4 to 10
                    const innerWidth = 1 + pulse * 2; // 1 to 3
                    const outerAlpha = 0.2 + pulse * 0.3; // 0.2 to 0.5

                    // Outer glow (pulsing)
                    laserGfx.moveTo(cx, cy).lineTo(tx, ty).stroke({ width: outerWidth, color: 0x22d3ee, alpha: outerAlpha });
                    // Inner beam (pulsing)
                    laserGfx.moveTo(cx, cy).lineTo(tx, ty).stroke({ width: innerWidth, color: 0x22d3ee, alpha: 0.9 });
                    // Core (white center, steady)
                    laserGfx.moveTo(cx, cy).lineTo(tx, ty).stroke({ width: 1, color: 0xffffff, alpha: 0.9 });
                }

                // Core hover text ("ACCESS SYSTEM" when hovering over core)
                const hoverText = refs.current.ui.hoverText;
                if (hoverText) {
                    const { mousePos: mpos, isCoreSelected: coreSelected, selectedTurretType: turretType, selectedTurretId: turretId } = useGameStore.getState();
                    if (isNearCore(mpos, 50) && !coreSelected && !turretType && !turretId) {
                        hoverText.visible = true;
                        hoverText.x = cx;
                        hoverText.y = cy - CORE_HOVER_RADIUS;

                        // Draw dashed hover ring
                        if (!isCoreSelected && sel) {
                            sel.clear();
                            for (let i = 0; i < 18; i++) {
                                const start = i * Math.PI / 9;
                                sel.arc(cx, cy, CORE_HOVER_RADIUS, start, start + Math.PI / 18);
                            }
                            sel.stroke({ width: 1, color: 0xffffff, alpha: 0.3 });
                        }
                    } else { hoverText.visible = false; }
                }
            };

            const updateTurretGraphics = (state, centerX, centerY) => {
                const { layers, pools, textures, app } = refs.current;
                if (!layers) return;
                const aliveIds = new Set();
                for (let i = 0; i < turretSystem.count; i++) aliveIds.add(turretSystem.items[i].id);
                RenderSystem.syncPool(pools.turrets, aliveIds, layers.turrets);

                const context = {
                    state, dims: dims.current, selectedTurretId,
                    getTexture: (t, e) => RenderSystem.getTurretTexture(e.type, e.color, textures, app),
                    getPipTexture: () => RenderSystem.getPipTexture(textures, app)
                };

                if (!pools.rangeSprites) {
                    pools.rangeSprites = new Map();
                    pools.rangeContainer = new PIXI.Container();
                    pools.rangeContainer.blendMode = 'max';
                    layers.turrets.addChildAt(pools.rangeContainer, 0);
                }
                const { rangeContainer, rangeSprites } = pools, activeRange = new Set();

                for (let i = 0; i < turretSystem.count; i++) {
                    const t = turretSystem.get(i), id = t.id;
                    if (isAreaTurret(t.type)) {
                        activeRange.add(id);
                        let s = rangeSprites.get(id);
                        if (!s) { s = new PIXI.Sprite(); s.anchor.set(0.5); rangeContainer.addChild(s); rangeSprites.set(id, s); }
                        const effRange = Math.round(getTurretEffectiveStats(t, state, null, state.gameTime).effectiveRange);
                        const key = `${effRange}_${t.color}`;
                        if (s._rangeKey !== key) { s.texture = RenderSystem.getRangeTexture(effRange, t.color, textures); s._rangeKey = key; }
                        s.x = t.x; s.y = t.y; s.visible = true;
                    }
                    let c = pools.turrets.get(id);
                    if (!c) { c = RenderSystem.createEntityContainer(['range', 'prismLines', 'chargeBar']); layers.turrets.addChild(c); pools.turrets.set(id, c); }
                    c.position.set(t.x, t.y);

                    const prism = c['prismLines'] || c.getChildByLabel('prismLines'); prism.clear();
                    if (t.type === TurretType.PRISM) {
                        const rSq = (TURRET_STATS[TurretType.PRISM].range * 1.1) ** 2;
                        for (let j = 0; j < turretSystem.count; j++) {
                            const other = turretSystem.items[j];
                            const dx = other.x - t.x, dy = other.y - t.y;
                            if (other.id !== id && other.type !== TurretType.PRISM && dx * dx + dy * dy <= rSq) prism.moveTo(0, 0).lineTo(dx, dy);
                        }
                        prism.stroke({ width: 1, color: t.color, alpha: 0.3 });
                    }

                    let hpBar = c['hpBar'] || c.getChildByLabel?.('hpBar');
                    if (!hpBar && t.hp < (t.maxHp || GAME_CONSTANTS.TURRET_DEFAULT_HP)) { hpBar = new PIXI.Graphics(); hpBar.label = 'hpBar'; c.addChild(hpBar); c['hpBar'] = hpBar; }
                    if (hpBar) {
                        hpBar.clear();
                        const max = t.maxHp || GAME_CONSTANTS.TURRET_DEFAULT_HP, pct = Math.max(0, t.hp / max);
                        if (t.hp < max) {
                            hpBar.rect(-15, -25, 30, 4).fill(0x1f2937).rect(-15, -25, 30 * pct, 4).fill(pct > 0.5 ? 0x10b981 : (pct > 0.25 ? 0xf59e0b : 0xef4444)).rect(-15, -25, 30, 4).stroke({ width: 1, color: 0x374151 });
                            hpBar.visible = true;
                        } else hpBar.visible = false;
                    }
                    RenderSystem.renderEntity(c, t, 'TURRET', context);
                }
                for (const [id, s] of rangeSprites.entries()) if (!activeRange.has(id)) { rangeContainer.removeChild(s); s.destroy(); rangeSprites.delete(id); }
            };

            const updateEnemyGraphics = (state) => {
                const { layers, pools, textures, app } = refs.current;
                if (!layers) return;
                const pool = pools.enemies;
                while (pool.length < enemySystem.count) { const c = RenderSystem.createEntityContainer(['status', 'health', 'traits']); layers.enemies.addChild(c); pool.push(c); }

                for (let i = 0; i < enemySystem.count; i++) {
                    const c = pool[i], e = enemySystem.get(i);
                    c.x = e.x; c.y = e.y;
                    RenderSystem.renderEntity(c, e, 'ENEMY', { state, dims: dims.current, EnemyTrait, getTexture: (t, en) => RenderSystem.getEnemyTexture(en.type, en.color, en.radius, textures, app) });
                    c.visible = true;
                }
                for (let i = enemySystem.count; i < pool.length; i++) pool[i].visible = false;
            };

            const updateProjectileGraphics = (state) => {
                const { layers, pools, textures, app } = refs.current;
                if (!layers) return;
                const pool = pools.projectiles, context = { state, dims: dims.current, glowTexture: textures.glow, hexToNum: RenderSystem.hexToNum, getTexture: (t, e) => RenderSystem.getProjectileTexture(e.shape || 'CIRCLE', e.color, e.radius, textures, app) };

                while (pool.length < projectileSystem.count) { const c = RenderSystem.createEntityContainer(['shape']); layers.projectiles.addChild(c); pool.push(c); }
                for (let i = 0; i < projectileSystem.count; i++) {
                    const c = pool[i]; RenderSystem.renderEntity(c, projectileSystem.get(i), 'PROJECTILE', context); c.visible = true;
                }
                for (let i = projectileSystem.count; i < pool.length; i++) pool[i].visible = false;

                if (!pools.enemyProjectiles) pools.enemyProjectiles = [];
                const epPool = pools.enemyProjectiles;
                while (epPool.length < state.enemyProjectiles.length) { const s = new PIXI.Graphics(); layers.projectiles.addChild(s); epPool.push(s); }
                for (let i = 0; i < state.enemyProjectiles.length; i++) {
                    const p = state.enemyProjectiles[i], g = epPool[i];
                    g.clear().circle(0, 0, p.radius).fill(RenderSystem.hexToNum(p.color)).circle(0, 0, p.radius + 3).fill({ color: RenderSystem.hexToNum(p.color), alpha: 0.3 });
                    g.x = p.x; g.y = p.y; g.visible = true;
                }
                for (let i = state.enemyProjectiles.length; i < epPool.length; i++) epPool[i].visible = false;
            };

            const updateParticleGraphics = (state) => {
                const { containers: { particles: c }, textures: { particles: tex }, pools: { particles: pool } } = refs.current;
                if (!c || !tex) return;
                for (let i = 0; i < particleSystem.count; i++) {
                    let s = pool[i];
                    if (!s) { s = new PIXI.Sprite(tex); s.anchor.set(0.5); c.addChild(s); pool.push(s); }
                    s.x = particleSystem.x[i]; s.y = particleSystem.y[i]; s.alpha = particleSystem.life[i] / 30;
                    s.scale.set(particleSystem.size[i] / 8); s.tint = particleSystem.color[i]; s.visible = true;
                }
                for (let i = particleSystem.count; i < pool.length; i++) pool[i].visible = false;
                if (pool.length > 200 && pool.length > particleSystem.count * 2 && state.gameTime % 5000 < 16) {
                    while (pool.length > Math.max(100, particleSystem.count * 2)) { const s = pool.pop(); if (s) { c.removeChild(s); s.destroy(); } }
                }
            };

            const updateLightningGraphics = () => {
                const { layers, pools } = refs.current;
                if (!layers) return;
                let pool = pools.lightnings;
                if (!pool) { pool = []; pools.lightnings = pool; }

                while (pool.length < lightningSystem.items.length) {
                    const g = new PIXI.Graphics();
                    layers.projectiles.addChild(g);
                    pool.push({ g });
                }

                for (let i = 0; i < lightningSystem.items.length; i++) {
                    const l = lightningSystem.items[i];
                    const g = pool[i].g;
                    g.visible = true;
                    // Alpha fade out over time
                    const alpha = l.life / l.maxLife;

                    g.clear();
                    const dist = Math.hypot(l.x2 - l.x1, l.y2 - l.y1);
                    const steps = Math.max(1, Math.ceil(dist / 15));

                    g.moveTo(l.x1, l.y1);
                    for (let j = 1; j < steps; j++) {
                        const t = j / steps;
                        const nx = l.x1 + (l.x2 - l.x1) * t + (Math.random() - 0.5) * 20;
                        const ny = l.y1 + (l.y2 - l.y1) * t + (Math.random() - 0.5) * 20;
                        g.lineTo(nx, ny);
                    }
                    g.lineTo(l.x2, l.y2);

                    // Core white line
                    g.stroke({ width: l.width, color: 0xffffff, alpha: alpha });
                    // Outer colored glow
                    g.stroke({ width: l.width * 3, color: l.color, alpha: alpha * 0.5 });
                }
                for (let i = lightningSystem.items.length; i < pool.length; i++) {
                    pool[i].g.visible = false;
                }
            };

            const updateRingGraphics = () => {
                const { layers, pools } = refs.current;
                if (!layers) return;
                let pool = pools.rings;
                if (!pool) { pool = []; pools.rings = pool; }

                while (pool.length < expandingRingSystem.items.length) {
                    const g = new PIXI.Graphics();
                    layers.projectiles.addChild(g);
                    pool.push({ g });
                }

                for (let i = 0; i < expandingRingSystem.items.length; i++) {
                    const r = expandingRingSystem.items[i];
                    const g = pool[i].g;
                    g.visible = true;
                    g.clear();

                    const alpha = r.life / r.maxLife;
                    const hexColor = typeof r.color === 'string' ? RenderSystem.hexToNum(r.color) : r.color;

                    // Outer expanding ring
                    g.circle(r.x, r.y, r.radius);
                    g.stroke({ width: 3, color: hexColor, alpha: alpha });
                    // Inner faint fill
                    g.circle(r.x, r.y, r.radius);
                    g.fill({ color: hexColor, alpha: alpha * 0.1 });
                }

                for (let i = expandingRingSystem.items.length; i < pool.length; i++) {
                    pool[i].g.visible = false;
                }
            };

            const updateFloatingTextGraphics = (state) => {
                const { layers: L, pools } = refs.current; if (!L) return;
                const alive = new Set(state.texts.map(t => t.id));
                for (const [id, t] of pools.activeTexts) if (!alive.has(id)) { L.texts.removeChild(t); t.visible = false; pools.texts.push(t); pools.activeTexts.delete(id); }
                state.texts.forEach(t => {
                    let o = pools.activeTexts.get(t.id);
                    if (!o) {
                        o = pools.texts.pop() || new PIXI.Text({ text: '', style: { fontFamily: 'monospace', fontWeight: 'bold', fill: 0xffffff } });
                        if (!pools.activeTexts.has(t.id)) o.anchor.set(0.5);
                        L.texts.addChild(o); pools.activeTexts.set(t.id, o);
                    }
                    o.text = t.text; o.position.set(t.x, t.y); o.alpha = Math.max(0, t.life / 40); o.style.fontSize = t.size; o.style.fill = RenderSystem.hexToNum(t.color); o.visible = true;
                });
            };

            const updateCoreHoverText = (state, cx, cy) => {
                const ht = coreHoverTextRef.current; if (!ht) return;
                const { mousePos: m, isCoreSelected: cs, selectedTurretType: tt, selectedTurretId: tid } = useGameStore.getState();
                if (isNearCore(m, 50) && !cs && !tt && !tid) {
                    ht.visible = true; ht.position.set(cx, cy - CORE_HOVER_RADIUS);
                    const sel = coreContainerRef.current?.getChildByLabel('selection');
                    if (!cs && sel) { sel.clear(); for (let i = 0; i < 18; i++) sel.arc(cx, cy, CORE_HOVER_RADIUS, i * Math.PI / 9, i * Math.PI / 9 + Math.PI / 18); sel.stroke({ width: 1, color: 0xffffff, alpha: 0.3 }); }
                } else ht.visible = false;
            };

            const loopCallbacks = {
                spawnParticles, spawnDirectional, spawnSingleParticle, spawnFloatingText, spawnProjectile, spawnRailgunBeam, spawnLightning,
                setGameState, setGameSpeed, getPrismBuff, getTurretEffectiveStats,
                getDistanceSq: Vec.distSq,
                handleProjectileHit,
                updatePixiGraphics,
                dragRef,
                refs // Fix for TypeError: Cannot read properties of undefined (reading 'current') in placeTurret
            };

            useGameLoop(refs, dims, loopCallbacks);
            const getScaledMousePos = (e) => {
                const canvas = canvasRef.current;
                if (!canvas) return { x: 0, y: 0 };
                const rect = canvas.getBoundingClientRect();
                return { x: e.clientX - rect.left, y: e.clientY - rect.top };
            };

            // @mouse-down — Handles turret placement, selection, and drag start
            const handleMouseDown = (e) => {
                if (gameState !== GameStatus.PLAYING) return;
                if (e.button !== 0) return;

                // FIX #5: Prevent click-through from UI buttons
                if (e.target !== canvasRef.current) return;

                const { x, y } = getScaledMousePos(e);

                if (selectedTurretType) {
                    const placed = turretManager.placeTurret(selectedTurretType, x, y, useGameStore.getState(), loopCallbacks);
                    if (placed) {
                        // Set flag to prevent handleMouseUp from selecting the just-placed turret
                        dragRef.current.justPlacedTurret = true;
                        // Turret type stays selected - right-click to cancel (see handleCanvasContextMenu)
                    } else {
                        spawnFloatingText(x, y, "CANNOT BUILD", COLORS.RED, 16);
                    }
                    return;
                }

                if (!selectedTurretType) {
                    const state = useGameStore.getState();

                    // Check if clicked an enemy projectile (click-to-destroy)
                    for (let i = state.enemyProjectiles.length - 1; i >= 0; i--) {
                        const p = state.enemyProjectiles[i];
                        const d = (x - p.x) ** 2 + (y - p.y) ** 2;
                        if (d < (p.radius + 15) ** 2) {
                            // Destroy the enemy projectile
                            spawnParticles(p.x, p.y, p.color, 8);
                            spawnFloatingText(p.x, p.y, 'ZAP!', COLORS.CYAN, 14);
                            state.enemyProjectiles.splice(i, 1);
                            return; // Don't process further clicks
                        }
                    }

                    // Check Enemy Dragging (Iterate SoA)
                    for (let i = enemySystem.count - 1; i >= 0; i--) {
                        const ex = enemySystem.x[i];
                        const ey = enemySystem.y[i];
                        const er = enemySystem.radius[i];
                        const type = enemySystem.type[i];

                        if (type === EnemyType.BOSS || type === EnemyType.MINIBOSS) continue;

                        const dx = x - ex;
                        const dy = y - ey;
                        const d = dx * dx + dy * dy;

                        if (d < (er + 15) ** 2) {
                            dragRef.current = {
                                isDragging: true,
                                enemyId: enemySystem.ids[i],
                                startX: ex,
                                startY: ey,
                                currentX: ex,
                                currentY: ey
                            };
                            return;
                        }
                    }
                }
            };

            // @mouse-move — Handles hover preview and enemy dragging
            const handleMouseMove = (e) => {
                const pos = getScaledMousePos(e);
                setMousePos(pos);

                if (dragRef.current.isDragging && dragRef.current.enemyId) {
                    const dx = pos.x - dragRef.current.startX;
                    const dy = pos.y - dragRef.current.startY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const maxDrag = BASE_DRAG_RADIUS + (useGameStore.getState().coreLevel * DRAG_RADIUS_PER_LEVEL);

                    let tx = pos.x;
                    let ty = pos.y;

                    if (dist > maxDrag) {
                        const angle = Math.atan2(dy, dx);
                        tx = dragRef.current.startX + Math.cos(angle) * maxDrag;
                        ty = dragRef.current.startY + Math.sin(angle) * maxDrag;
                    }

                    dragRef.current.currentX = tx;
                    dragRef.current.currentY = ty;
                }
            };

            // @mouse-up — Ends drag operations
            const handleMouseUp = (e) => {
                if (gameState !== GameStatus.PLAYING) return;
                if (e.button !== 0) return;

                // FIX #5: Prevent click-through from UI buttons
                if (e.target !== canvasRef.current) return;

                if (dragRef.current.isDragging) {
                    dragRef.current.isDragging = false;
                    dragRef.current.enemyId = null;
                    return;
                }

                const { x, y } = getScaledMousePos(e);

                const distToCenter = Vec.distSq({ x, y }, { x: dims.current.w / 2, y: dims.current.h / 2 });
                if (distToCenter < 2500) {
                    setIsCoreSelected(true);
                    setSelectedTurretId(null);
                    setShowUpgrades(false);
                    return;
                }

                // Skip turret selection if we just placed a turret on this click
                if (dragRef.current.justPlacedTurret) {
                    dragRef.current.justPlacedTurret = false;
                    return;
                }

                // Check for Turret Click
                let clickedTurretId = null;
                for (let i = 0; i < turretSystem.count; i++) {
                    const t = turretSystem.items[i];
                    const tr = t.radius || 20;
                    if ((t.x - x) * (t.x - x) + (t.y - y) * (t.y - y) < (tr + 10) * (tr + 10)) {
                        clickedTurretId = t.id;
                        break;
                    }
                }

                if (clickedTurretId) {
                    setSelectedTurretId(clickedTurretId);
                    setShowUpgrades(false);
                    setIsCoreSelected(false);
                }
                else {
                    // Close all UI menus when clicking on empty canvas
                    setSelectedTurretId(null);
                    setIsCoreSelected(false);
                    setShowUpgrades(false);
                    setShowCodex(false);
                }
            };

            const handleCanvasContextMenu = (e) => {
                e.preventDefault();
                if (gameState !== GameStatus.PLAYING) return;
                if (selectedTurretType) { setSelectedTurretType(null); return; }
                const { x, y } = getScaledMousePos(e);

                // Find closest turret (hitbox 20px radius)
                let foundIdx = -1;
                for (let i = 0; i < turretSystem.count; i++) {
                    const t = turretSystem.items[i];
                    const dx = t.x - x;
                    const dy = t.y - y;
                    if (dx * dx + dy * dy < 400) { foundIdx = i; break; }
                }

                if (foundIdx !== -1) {
                    const tData = turretSystem.get(foundIdx);
                    // Clear selection if selling the selected turret
                    if (selectedTurretId === tData.id) setSelectedTurretId(null);

                    turretManager.sellTurret(foundIdx, useGameStore.getState(), { spawnParticles });
                } else { setSelectedTurretId(null); }
            };

            return (
                <div className="relative w-full h-screen bg-gray-950 overflow-hidden font-rajdhani selection:bg-cyan-500/30">

                    {/* CRT Overlay Effects */}
                    <div className="absolute inset-0 z-0 bg-slate-900 pointer-events-none retro-grid opacity-20" />
                    <div className="absolute inset-0 z-40 pointer-events-none scanlines mix-blend-overlay opacity-30"></div>

                    {/* TOP HUD BAR */}
                    <div className="absolute top-0 left-0 right-0 h-16 px-6 flex justify-between items-center z-30 pointer-events-none">

                        {/* LEFT: STATUS */}
                        <div className="flex items-center gap-6 pointer-events-auto">
                            <div className="flex flex-col">
                                <div className="flex items-center gap-2">
                                    <div className="text-2xl font-bold text-white font-mono tracking-wider flex items-center gap-2">
                                        <Activity className="w-5 h-5 text-red-500" />
                                        {uiStats.health} <span className="text-sm text-slate-500">/ {uiStats.maxHealth}</span>
                                    </div>
                                    {/* CRYO SHIELD INDICATOR */}
                                    {uiStats.activeModules.includes(CoreModuleType.ICE_SHELL) && (
                                        <div className={`ml-2 px-2 py-0.5 rounded text-[10px] font-bold border flex items-center gap-1 ${(uiStats.moduleCooldowns[CoreModuleType.ICE_SHELL] || 0) <= 0
                                            ? 'bg-cyan-900/50 border-cyan-500 text-cyan-400 shadow-[0_0_10px_rgba(34,211,238,0.3)]'
                                            : 'bg-slate-800 border-slate-600 text-slate-500'
                                            }`}>
                                            <Shield className="w-3 h-3" />
                                            {(uiStats.moduleCooldowns[CoreModuleType.ICE_SHELL] || 0) <= 0 ? "READY" : `${Math.ceil(uiStats.moduleCooldowns[CoreModuleType.ICE_SHELL] / 1000)} s`}
                                        </div>
                                    )}
                                </div>
                                <div className="w-48 h-1 bg-slate-800 rounded-full mt-1 overflow-hidden">
                                    <div className="h-full bg-red-500 transition-all duration-300" style={{ width: `${(uiStats.health / uiStats.maxHealth) * 100}% ` }}></div>
                                </div>
                            </div>

                            <div className="flex items-center gap-2 bg-slate-900 px-4 py-1.5 rounded-full border border-slate-700">
                                <CircleDollarSign className="w-4 h-4 text-amber-400" />
                                <span className="text-xl font-bold text-amber-200 font-mono tracking-wide">{uiStats.money}</span>
                            </div>

                            {/* Active Mutations */}
                            {(uiStats.activeMutations?.length > 0) && (
                                <div className="flex gap-1">
                                    {uiStats.activeMutations.map((m, i) => {
                                        const def = MUTATION_DEFS[m];
                                        return <div key={i} className={`px-2 py-0.5 rounded text-[10px] font-bold ${def?.isBuff ? 'bg-emerald-900/50 text-emerald-400 border border-emerald-500/30' : 'bg-red-900/50 text-red-400 border border-red-500/30'}`}>{def?.name || m}</div>;
                                    })}
                                </div>
                            )}

                        </div>

                        {/* CENTER: CLOCK */}
                        <div className="absolute left-1/2 -translate-x-1/2 top-4">
                            <div className="bg-slate-900 border border-slate-700 px-6 py-1 rounded-full shadow-lg text-center">
                                <div className="text-2xl font-bold text-white font-orbitron tracking-widest">
                                    {Math.floor(gameDuration / 60).toString().padStart(2, '0')}:{(gameDuration % 60).toString().padStart(2, '0')}
                                </div>
                            </div>
                        </div>

                        {/* RIGHT: TOOLS */}
                        <div className="flex items-center gap-3 pointer-events-auto">
                            {/* SPEED CONTROLS */}
                            <div className="flex bg-slate-900 rounded-lg border border-slate-700 p-1 mr-2">
                                <button onClick={() => setGameSpeed(0)} className={`p-1.5 rounded hover:bg-slate-700 ${gameSpeed === 0 ? 'bg-slate-700 text-white' : 'text-slate-400'} `}><Pause className="w-4 h-4" /></button>
                                <button onClick={() => setGameSpeed(1)} className={`p-1.5 rounded hover:bg-slate-700 ${gameSpeed === 1 ? 'bg-slate-700 text-white' : 'text-slate-400'} `}><Play className="w-4 h-4" /></button>
                                <button onClick={() => setGameSpeed(2)} className={`p-1.5 rounded hover:bg-slate-700 ${gameSpeed === 2 ? 'bg-slate-700 text-white' : 'text-slate-400'} `}><FastForward className="w-4 h-4" /></button>
                            </div>

                            {/* Ultimate Indicator */}
                            {uiStats.coreLevel >= 5 && uiStats.ultimateCharge >= 100 && (
                                <div className="px-3 py-1.5 rounded border border-red-500 bg-red-900/50 text-red-300 text-xs font-bold tracking-wider animate-pulse shadow-[0_0_10px_rgba(239,68,68,0.4)]" title="Press X to activate ultimate">
                                    ULT READY [X]
                                </div>
                            )}

                            {[
                                [() => setShowCodex(true), 'purple', 'Codex', Info],
                                [saveGame, 'emerald', 'Save Game', Save],
                                [loadGame, 'cyan', 'Load Game', Upload]
                            ].map(([fn, color, title, Icon], i) =>
                                <button key={i} onClick={fn}
                                    className={`p-2 rounded bg-slate-900 border border-slate-700 text-${color}-400 hover:bg-slate-800 hover:text-white transition-colors`}
                                    title={title}>
                                    <Icon className="w-5 h-5" />
                                </button>
                            )}

                            <button
                                onClick={() => {
                                    setShowUpgrades(!showUpgrades);
                                    setShowTechLab(false);
                                    setSelectedTurretId(null);
                                    setIsCoreSelected(false);
                                }}
                                className={`flex items-center gap-2 px-3 py-2 rounded font-bold border transition-all
                                    ${showUpgrades
                                        ? 'bg-purple-600 text-white border-purple-400 shadow-[0_0_15px_rgba(168,85,247,0.4)]'
                                        : 'bg-slate-900 text-purple-300 border-slate-700 hover:border-purple-500/50 hover:shadow-[0_0_10px_rgba(168,85,247,0.2)]'} `}
                            >
                                <Cpu className="w-4 h-4" />
                                <span className="text-xs tracking-wider font-orbitron">MODS</span>
                            </button>
                        </div>
                    </div>

                    {saveMessage && (<div className="absolute top-24 right-8 bg-slate-900/90 text-white px-6 py-3 rounded-lg border border-slate-600 shadow-xl z-50 font-bold tracking-widest animate-fade-in-up">{saveMessage}</div>)}

                    <canvas
                        ref={canvasRef}
                        className={`absolute inset-0 w-full h-full shadow-2xl shadow-blue-900/20 bg-black border border-slate-800 z-10 ${dragRef.current.isDragging ? 'cursor-grabbing' : (selectedTurretType ? 'cursor-crosshair' : 'cursor-default')} `}
                        onMouseMove={handleMouseMove}
                        onMouseEnter={() => setIsHoveringCanvas(true)}
                        onMouseLeave={() => setIsHoveringCanvas(false)}
                        onMouseDown={handleMouseDown}
                        onMouseUp={handleMouseUp}
                        onContextMenu={handleCanvasContextMenu}
                    />

                    <div className="absolute top-24 left-8 pointer-events-none text-slate-500 text-[10px] font-mono z-10 opacity-50">
                        RIGHT CLICK: SELL TOWER | CLICK-DRAG ENEMIES TO REPOSITION
                    </div>
                    <CoreMenu spawnParticles={spawnParticles} />
                    <TurretDetailPanel spawnParticles={spawnParticles} />
                    <BuildMenu />
                    <UpgradesPanel />
                    {showTechLab && <TechLabModal />}
                    <GameOverlays earnedTechPoints={earnedTechPoints} />
                    {showCodex && <CodexModal />}
                </div >
            );
        };

        const App = () => {
            return (
                <div className="w-full h-screen bg-black overflow-hidden">
                    <GameCanvas />
                </div>
            );
        };
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>





